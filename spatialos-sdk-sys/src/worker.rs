/* automatically generated by rust-bindgen */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SCHEMA_MAP_KEY_FIELD_ID: u32 = 1;
pub const SCHEMA_MAP_VALUE_FIELD_ID: u32 = 2;
pub const WORKER_DEFAULTS_SEND_QUEUE_CAPACITY: u32 = 4096;
pub const WORKER_DEFAULTS_RECEIVE_QUEUE_CAPACITY: u32 = 4096;
pub const WORKER_DEFAULTS_LOG_MESSAGE_QUEUE_CAPACITY: u32 = 256;
pub const WORKER_DEFAULTS_BUILT_IN_METRICS_REPORT_PERIOD_MILLIS: u32 = 5000;
pub const WORKER_DEFAULTS_CONNECTION_TIMEOUT_MILLIS: u32 = 60000;
pub const WORKER_DEFAULTS_DEFAULT_COMMAND_TIMEOUT_MILLIS: u32 = 5000;
pub const WORKER_DEFAULTS_TCP_MULTIPLEX_LEVEL: u32 = 32;
pub const WORKER_DEFAULTS_TCP_SEND_BUFFER_SIZE: u32 = 65536;
pub const WORKER_DEFAULTS_TCP_RECEIVE_BUFFER_SIZE: u32 = 65536;
pub const WORKER_DEFAULTS_TCP_NO_DELAY: u32 = 0;
pub const WORKER_DEFAULTS_RAKNET_HEARTBEAT_TIMEOUT_MILLIS: u32 = 60000;
pub const WORKER_DEFAULTS_KCP_FAST_RETRANSMISSION: u32 = 0;
pub const WORKER_DEFAULTS_KCP_EARLY_RETRANSMISSION: u32 = 0;
pub const WORKER_DEFAULTS_KCP_NON_CONCESSIONAL_FLOW_CONTROL: u32 = 0;
pub const WORKER_DEFAULTS_KCP_MULTIPLEX_LEVEL: u32 = 32;
pub const WORKER_DEFAULTS_KCP_UPDATE_INTERVAL_MILLIS: u32 = 20;
pub const WORKER_DEFAULTS_KCP_MIN_RTO_MILLIS: u32 = 0;
pub const WORKER_DEFAULTS_KCP_WINDOW_SIZE: u32 = 100;
pub const WORKER_DEFAULTS_KCP_ENABLE_ERASURE_CODEC: u32 = 0;
pub const WORKER_DEFAULTS_ERASURE_CODEC_ORIGINAL_PACKET_COUNT: u32 = 10;
pub const WORKER_DEFAULTS_ERASURE_CODEC_RECOVERY_PACKET_COUNT: u32 = 2;
pub const WORKER_DEFAULTS_ERASURE_CODEC_WINDOW_SIZE: u32 = 8;
pub const WORKER_DEFAULTS_HEARTBEAT_INTERVAL_MILLIS: u32 = 10000;
pub const WORKER_DEFAULTS_HEARTBEAT_TIMEOUT_MILLIS: u32 = 60000;
pub const WORKER_DEFAULTS_LOG_PREFIX: &'static [u8; 14usize] = b"protocol-log-\0";
pub const WORKER_DEFAULTS_MAX_LOG_FILES: u32 = 10;
pub const WORKER_DEFAULTS_MAX_LOG_FILE_SIZE_BYTES: u32 = 1048576;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type Schema_FieldId = u32;
pub type Schema_EntityId = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_CommandRequest {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_CommandResponse {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_ComponentData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_ComponentUpdate {
    _unused: [u8; 0],
}
/// An object, roughly corresponding to an instance of a "type" as defined in schema.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_Object {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate a command request schema type instance. The component ID should be as defined in
    /// the schema, and the command_index should be the 1-based position of the command in the order
    /// the commands appear in component in the schema.
    pub fn Schema_CreateCommandRequest(
        component_id: Schema_FieldId,
        command_index: Schema_FieldId,
    ) -> *mut Schema_CommandRequest;
}
extern "C" {
    /// Free the resources associated with a command request schema type instance.
    pub fn Schema_DestroyCommandRequest(request: *mut Schema_CommandRequest);
}
extern "C" {
    /// Get the component ID of a command request.
    pub fn Schema_GetCommandRequestComponentId(
        request: *const Schema_CommandRequest,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Get the 1-based position of the command in the order the commands appear in the schema.
    pub fn Schema_GetCommandRequestCommandIndex(
        request: *const Schema_CommandRequest,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Get the command request as a Schema_Object.
    pub fn Schema_GetCommandRequestObject(
        request: *mut Schema_CommandRequest,
    ) -> *mut Schema_Object;
}
extern "C" {
    /// Allocate a command response schema type instance. The component ID should be as defined in
    /// the schema, and the command_index should be the 1-based position of the command in the order
    /// the commands appear in the component in schema.
    pub fn Schema_CreateCommandResponse(
        component_id: Schema_FieldId,
        command_index: Schema_FieldId,
    ) -> *mut Schema_CommandResponse;
}
extern "C" {
    /// Free the resources associated with a command response schema type instance.
    pub fn Schema_DestroyCommandResponse(response: *mut Schema_CommandResponse);
}
extern "C" {
    /// Get the component ID of a command response.
    pub fn Schema_GetCommandResponseComponentId(
        request: *const Schema_CommandResponse,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Get the 1-based position of the command in the order the commands appear in the schema.
    pub fn Schema_GetCommandResponseCommandIndex(
        request: *const Schema_CommandResponse,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Get the command response as a Schema_Object.
    pub fn Schema_GetCommandResponseObject(
        response: *mut Schema_CommandResponse,
    ) -> *mut Schema_Object;
}
extern "C" {
    /// Allocate a component data snapshot schema type instance.
    pub fn Schema_CreateComponentData(component_id: Schema_FieldId) -> *mut Schema_ComponentData;
}
extern "C" {
    /// Free the resources associated with a component data snapshot schema type instance.
    pub fn Schema_DestroyComponentData(data: *mut Schema_ComponentData);
}
extern "C" {
    /// Get the component ID of a component data snapshot.
    pub fn Schema_GetComponentDataComponentId(data: *const Schema_ComponentData) -> Schema_FieldId;
}
extern "C" {
    /// Get the command data snapshot as a Schema_Object.
    pub fn Schema_GetComponentDataFields(data: *mut Schema_ComponentData) -> *mut Schema_Object;
}
extern "C" {
    /// Allocate a component update schema type instance.
    pub fn Schema_CreateComponentUpdate(
        component_id: Schema_FieldId,
    ) -> *mut Schema_ComponentUpdate;
}
extern "C" {
    /// Free the resources associated with a component update schema type instance.
    pub fn Schema_DestroyComponentUpdate(update: *mut Schema_ComponentUpdate);
}
extern "C" {
    /// Get the component ID of a component update.
    pub fn Schema_GetComponentUpdateComponentId(
        update: *const Schema_ComponentUpdate,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Get an object representing the non-event fields in a component update. This object should be used
    /// as if it had one field for each field in the component, whose type corresponds to the type of the
    /// field as defined in schema. Note that when an option, list or map field in a component is set to
    /// the empty value, it will not / should not appear here. Instead, use
    /// Schema_IndexComponentUpdateClearedField and related functions.
    pub fn Schema_GetComponentUpdateFields(
        update: *mut Schema_ComponentUpdate,
    ) -> *mut Schema_Object;
}
extern "C" {
    /// Get an object representing the event fields in a component update. This object should be used
    /// as if it had one field for each event in the component. Each field behaves like a list (may have
    /// multiple instances of the same event), and the field ID of an event is its 1-based position in
    /// the order the events appear in the component in the schema.
    pub fn Schema_GetComponentUpdateEvents(
        update: *mut Schema_ComponentUpdate,
    ) -> *mut Schema_Object;
}
extern "C" {
    /// Clears the list of fields that this update sets to the empty value (for option, list and map
    /// fields in a component).
    pub fn Schema_ClearComponentUpdateClearedFields(update: *mut Schema_ComponentUpdate);
}
extern "C" {
    /// Specifies that this update sets and option, list or map field in a component to the empty
    /// value.
    pub fn Schema_AddComponentUpdateClearedField(
        update: *mut Schema_ComponentUpdate,
        field_id: Schema_FieldId,
    );
}
extern "C" {
    /// Returns the number of option, list and map fields in a component that this update sets to the
    /// empty value.
    pub fn Schema_GetComponentUpdateClearedFieldCount(update: *const Schema_ComponentUpdate)
        -> u32;
}
extern "C" {
    /// Returns the field ID of an option, list or map field which is set to the empty value by this
    /// update.
    pub fn Schema_IndexComponentUpdateClearedField(
        update: *const Schema_ComponentUpdate,
        index: u32,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Returns all field IDs of option, list, or map fields which are set to the empty value by this
    /// component. The output_array should have space for
    /// Schema_GetComponentUpdateClearedFieldCount(update) field IDs.
    pub fn Schema_GetComponentUpdateClearedFieldList(
        update: *const Schema_ComponentUpdate,
        output_array: *mut Schema_FieldId,
    );
}
extern "C" {
    /// Completely clears all fields in the given object.
    pub fn Schema_Clear(object: *mut Schema_Object);
}
extern "C" {
    /// Completely clears the given field ID in the given object.
    pub fn Schema_ClearField(object: *mut Schema_Object, field_id: Schema_FieldId);
}
extern "C" {
    /// Copies all fields from `src` to `dst`. The copy is shallow; changes made to object fields in the
    /// source will also be reflected in the copied fields.
    ///
    /// If `src == dst`, or if the objects are not associated with the same root schema type instance, no
    /// operation is performed.
    pub fn Schema_ShallowCopy(src: *const Schema_Object, dst: *mut Schema_Object);
}
extern "C" {
    /// Copies over a field from `src` to `dst`. If multiple fields with the given field_id exist all
    /// are copied. The copy is shallow; changes made to object fields in the source will also be
    /// reflected in the copied fields.
    ///
    /// If `src == dst`, or if the objects are not associated with the same root schema type instance, no
    /// operation is performed.
    pub fn Schema_ShallowCopyField(
        src: *const Schema_Object,
        dst: *mut Schema_Object,
        field_id: Schema_FieldId,
    );
}
extern "C" {
    /// Allocates an orphaned Schema_Object in memory owned by the given Schema_Object instance. The
    /// returned object is owned by the associated schema type instance, but is not reachable from any
    /// other object. The memory is freed by a call to Schema_Destroy.
    pub fn Schema_AllocateObject(object: *const Schema_Object) -> *mut Schema_Object;
}
extern "C" {
    /// Allocates a buffer of the specified length in bytes from memory owned by the given Schema_Object
    /// instance. The memory is freed by a call to Schema_Destroy.
    ///
    /// Note: this is useful for allocating memory that must live as long as the root schema type
    /// instance, for example to pass to Schema_MergeFromBuffer.
    pub fn Schema_AllocateBuffer(object: *mut Schema_Object, length: u32) -> *mut u8;
}
extern "C" {
    /// Merges the given buffer into the given object, appending all fields. This function
    /// can fail; if the return value is zero, call Schema_GetError to obtain an error string.
    ///
    /// Note: the provided buffer is not copied, and must live as long as the root schema type instance.
    pub fn Schema_MergeFromBuffer(object: *mut Schema_Object, buffer: *const u8, length: u32)
        -> u8;
}
extern "C" {
    /// Computes the serialized length of the given Schema_Object.
    pub fn Schema_GetWriteBufferLength(object: *const Schema_Object) -> u32;
}
extern "C" {
    /// Serializes the given object into the provided buffer, which _must_ have space at
    /// least equal to the length returned by Schema_WriteBufferLength. This function can
    /// fail; if the return value is zero, call Schema_GetError to obtain an error string.
    ///
    /// WriteToBuffer re-calculates the size of the underlying Schema_Object and is therefore less
    /// performant than Schema_SerializeToBuffer. Schema_WriteToBuffer is deprecated and will be removed
    /// in 14+ releases.
    ///
    /// `length` must equal the value returned by `Schema_GetWriteBufferLength`. Otherwise, the behavior
    /// is undefined.
    pub fn Schema_WriteToBuffer(object: *const Schema_Object, buffer: *mut u8) -> u8;
}
extern "C" {
    pub fn Schema_SerializeToBuffer(
        object: *const Schema_Object,
        buffer: *mut u8,
        length: u32,
    ) -> u8;
}
extern "C" {
    /// Obtains the most recent error encountered by any object associated with the given object. The
    /// buffer is owned by the schema object that manages the memory of `object`, and may get replaced
    /// after calling another Schema function. Returns `NULL` if no error has occurred within the given
    /// object.
    pub fn Schema_GetError(object: *const Schema_Object) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Returns the number of unique field IDs used in the Schema_Object.
    pub fn Schema_GetUniqueFieldIdCount(object: *const Schema_Object) -> u32;
}
extern "C" {
    /// Returns the sorted list of unique field IDs used in the Schema_Object. The buffer parameter
    /// must have space remaining for as many field IDs as indicated by Schema_GetUniqueFieldIdCount.
    pub fn Schema_GetUniqueFieldIds(object: *const Schema_Object, buffer: *mut u32);
}
extern "C" {
    pub fn Schema_AddFloat(object: *mut Schema_Object, field_id: Schema_FieldId, value: f32);
}
extern "C" {
    pub fn Schema_AddDouble(object: *mut Schema_Object, field_id: Schema_FieldId, value: f64);
}
extern "C" {
    pub fn Schema_AddBool(object: *mut Schema_Object, field_id: Schema_FieldId, value: u8);
}
extern "C" {
    pub fn Schema_AddInt32(object: *mut Schema_Object, field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddInt64(object: *mut Schema_Object, field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddUint32(object: *mut Schema_Object, field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddUint64(object: *mut Schema_Object, field_id: Schema_FieldId, value: u64);
}
extern "C" {
    pub fn Schema_AddSint32(object: *mut Schema_Object, field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddSint64(object: *mut Schema_Object, field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddFixed32(object: *mut Schema_Object, field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddFixed64(object: *mut Schema_Object, field_id: Schema_FieldId, value: u64);
}
extern "C" {
    pub fn Schema_AddSfixed32(object: *mut Schema_Object, field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddSfixed64(object: *mut Schema_Object, field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddEntityId(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        value: Schema_EntityId,
    );
}
extern "C" {
    pub fn Schema_AddEnum(object: *mut Schema_Object, field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddBytes(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        buffer: *const u8,
        length: u32,
    );
}
extern "C" {
    pub fn Schema_AddObject(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
    ) -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_AddFloatList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const f32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddDoubleList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const f64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddBoolList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u8,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddInt32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddInt64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddUint32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddUint64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSint32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSint64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddFixed32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddFixed64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSfixed32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSfixed64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddEntityIdList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const Schema_EntityId,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddEnumList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_GetFloatCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetDoubleCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBoolCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetInt32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetInt64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSint32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSint64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSfixed32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSfixed64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetEntityIdCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetEnumCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytesCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetObjectCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFloat(object: *const Schema_Object, field_id: Schema_FieldId) -> f32;
}
extern "C" {
    pub fn Schema_GetDouble(object: *const Schema_Object, field_id: Schema_FieldId) -> f64;
}
extern "C" {
    pub fn Schema_GetBool(object: *const Schema_Object, field_id: Schema_FieldId) -> u8;
}
extern "C" {
    pub fn Schema_GetInt32(object: *const Schema_Object, field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetInt64(object: *const Schema_Object, field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetUint32(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint64(object: *const Schema_Object, field_id: Schema_FieldId) -> u64;
}
extern "C" {
    pub fn Schema_GetSint32(object: *const Schema_Object, field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetSint64(object: *const Schema_Object, field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetFixed32(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed64(object: *const Schema_Object, field_id: Schema_FieldId) -> u64;
}
extern "C" {
    pub fn Schema_GetSfixed32(object: *const Schema_Object, field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetSfixed64(object: *const Schema_Object, field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetEntityId(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
    ) -> Schema_EntityId;
}
extern "C" {
    pub fn Schema_GetEnum(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytesLength(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytes(object: *const Schema_Object, field_id: Schema_FieldId) -> *const u8;
}
extern "C" {
    pub fn Schema_GetObject(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
    ) -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_IndexFloat(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> f32;
}
extern "C" {
    pub fn Schema_IndexDouble(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> f64;
}
extern "C" {
    pub fn Schema_IndexBool(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Schema_IndexInt32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i32;
}
extern "C" {
    pub fn Schema_IndexInt64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i64;
}
extern "C" {
    pub fn Schema_IndexUint32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexUint64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u64;
}
extern "C" {
    pub fn Schema_IndexSint32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i32;
}
extern "C" {
    pub fn Schema_IndexSint64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i64;
}
extern "C" {
    pub fn Schema_IndexFixed32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexFixed64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u64;
}
extern "C" {
    pub fn Schema_IndexSfixed32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i32;
}
extern "C" {
    pub fn Schema_IndexSfixed64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i64;
}
extern "C" {
    pub fn Schema_IndexEntityId(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> Schema_EntityId;
}
extern "C" {
    pub fn Schema_IndexEnum(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexBytesLength(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexBytes(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> *const u8;
}
extern "C" {
    pub fn Schema_IndexObject(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_GetFloatList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut f32,
    );
}
extern "C" {
    pub fn Schema_GetDoubleList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut f64,
    );
}
extern "C" {
    pub fn Schema_GetBoolList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u8,
    );
}
extern "C" {
    pub fn Schema_GetInt32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i32,
    );
}
extern "C" {
    pub fn Schema_GetInt64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i64,
    );
}
extern "C" {
    pub fn Schema_GetUint32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u32,
    );
}
extern "C" {
    pub fn Schema_GetUint64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u64,
    );
}
extern "C" {
    pub fn Schema_GetSint32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i32,
    );
}
extern "C" {
    pub fn Schema_GetSint64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i64,
    );
}
extern "C" {
    pub fn Schema_GetFixed32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u32,
    );
}
extern "C" {
    pub fn Schema_GetFixed64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u64,
    );
}
extern "C" {
    pub fn Schema_GetSfixed32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i32,
    );
}
extern "C" {
    pub fn Schema_GetSfixed64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i64,
    );
}
extern "C" {
    pub fn Schema_GetEntityIdList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut Schema_EntityId,
    );
}
extern "C" {
    pub fn Schema_GetEnumList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u32,
    );
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
pub type Worker_EntityId = i64;
pub type Worker_ComponentId = u32;
pub type Worker_RequestId = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ConnectionFuture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DeploymentListFuture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_PlayerIdentityTokenResponseFuture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_LoginTokensResponseFuture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Locator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnasphotInputStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotOutputStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_Locator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotInputStream {
    _unused: [u8; 0],
}
pub const Worker_LogLevel_WORKER_LOG_LEVEL_DEBUG: Worker_LogLevel = 1;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_INFO: Worker_LogLevel = 2;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_WARN: Worker_LogLevel = 3;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_ERROR: Worker_LogLevel = 4;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_FATAL: Worker_LogLevel = 5;
/// Enum defining the severities of log messages that can be sent to SpatialOS and received from the
/// SDK.
pub type Worker_LogLevel = u32;
/// The request was successfully executed and returned a response.
pub const Worker_StatusCode_WORKER_STATUS_CODE_SUCCESS: Worker_StatusCode = 1;
/// The request timed out before a response was received. It can be retried, but carefully - this
/// usually means the deployment is overloaded, so some sort of backoff should be used to avoid
/// making the problem worse. This can also be caused by the target worker's handling code failing
/// to respond to the command at all, perhaps due to a bug in its implementation.
pub const Worker_StatusCode_WORKER_STATUS_CODE_TIMEOUT: Worker_StatusCode = 2;
/// The target entity did not exist, or did not have the target component. This probably means
/// the entity either hasn't been created yet or has already been deleted. It might make sense to
/// retry the request if there is reason to believe the entity hasn't yet been created but will be
/// soon.
pub const Worker_StatusCode_WORKER_STATUS_CODE_NOT_FOUND: Worker_StatusCode = 3;
/// The request could not be executed by a worker, either because the worker lost authority over
/// the entity while handling the request, the entity was deleted while handling the request, or no
/// worker was authoritative over the entity at all. Assuming the deployment isn't irrecoverably
/// broken (e.g. due to misconfigured loadbalancing or crash-looping workers) this is a transient
/// failure and can be retried immediately.
pub const Worker_StatusCode_WORKER_STATUS_CODE_AUTHORITY_LOST: Worker_StatusCode = 4;
/// The worker did not have the required permissions to make the request. Permissions do not change
/// at runtime, so it doesn't make sense to retry the request.
pub const Worker_StatusCode_WORKER_STATUS_CODE_PERMISSION_DENIED: Worker_StatusCode = 5;
/// The command was delivered successfully, but the handler rejected it. Either the command was
/// delivered to a worker that explicitly rejected it by calling Connection::SendCommandFailure, or
/// the request data was rejected as invalid by SpatialOS itself. In the latter case, in
/// particular, Worker_Connection_SendCreateEntityRequest will return kApplicationError if an
/// entity ID reservation has expired, and Worker_Connection_SendEntityQueryResult will return
/// kApplicationError if the result set is incomplete.
pub const Worker_StatusCode_WORKER_STATUS_CODE_APPLICATION_ERROR: Worker_StatusCode = 6;
/// Some other error occurred. This likely indicates a bug in SpatialOS and should be reported.
pub const Worker_StatusCode_WORKER_STATUS_CODE_INTERNAL_ERROR: Worker_StatusCode = 7;
/// Enum defining possible command status codes.
pub type Worker_StatusCode = u32;
/// The remote call was successful, or we are successfully connected.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_SUCCESS:
    Worker_ConnectionStatusCode = 1;
/// Protocol violation, or some part of the system otherwise behaved in an unexpected way. Not
/// expected to occur in normal operation.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_INTERNAL_ERROR:
    Worker_ConnectionStatusCode = 2;
/// An argument provided by the caller was determined to be invalid. This is a local failure; no
/// actual attempt was made to contact the host. Not retryable.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_INVALID_ARGUMENT:
    Worker_ConnectionStatusCode = 3;
/// Failed due to a networking issue or otherwise unreachable host.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_NETWORK_ERROR:
    Worker_ConnectionStatusCode = 4;
/// A timeout provided by the caller or enforced by the system was exceeded. Can be retried.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_TIMEOUT:
    Worker_ConnectionStatusCode = 5;
/// Attempt was cancelled by the caller. Currently shouldn't happen; reserved for future use.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_CANCELLED:
    Worker_ConnectionStatusCode = 6;
/// Made contact with the host, but the request was explicitly rejected. Unlikely to be retryable.
/// Possible causes include: the request was made to the wrong host; the host considered the
/// request invalid for some othe reason.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_REJECTED:
    Worker_ConnectionStatusCode = 7;
/// The player identity token provided by the caller has expired. Generate a new one and retry.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_PLAYER_IDENTITY_TOKEN_EXPIRED : Worker_ConnectionStatusCode = 8 ;
/// The login token provided by the caller has expired. Generate a new one and retry.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_LOGIN_TOKEN_EXPIRED:
    Worker_ConnectionStatusCode = 9;
/// Failed because the deployment associated with the provided login token was at capacity.
/// Retryable.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_CAPACITY_EXCEEDED:
    Worker_ConnectionStatusCode = 10;
/// Failed due to rate-limiting of new connections to the deployment associated with the provided
/// login token. Retryable.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_RATE_EXCEEDED:
    Worker_ConnectionStatusCode = 11;
/// After a successful connection attempt, the server later explicitly terminated the connection.
/// Possible causes include: the deployment was stopped; the worker was killed due to
/// unresponsiveness.
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_SERVER_SHUTDOWN:
    Worker_ConnectionStatusCode = 12;
/// Possible status codes for a remote call, connection attempt, or connection migration attempt.
pub type Worker_ConnectionStatusCode = u32;
pub const Worker_Authority_WORKER_AUTHORITY_NOT_AUTHORITATIVE: Worker_Authority = 0;
pub const Worker_Authority_WORKER_AUTHORITY_AUTHORITATIVE: Worker_Authority = 1;
pub const Worker_Authority_WORKER_AUTHORITY_AUTHORITY_LOSS_IMMINENT: Worker_Authority = 2;
/// Enum defining the possible authority states for an entity component.
pub type Worker_Authority = u32;
pub const Worker_Alpha_ComponentUpdateLoopback_WORKER_COMPONENT_UPDATE_LOOPBACK_NONE:
    Worker_Alpha_ComponentUpdateLoopback = 0;
pub const Worker_Alpha_ComponentUpdateLoopback_WORKER_COMPONENT_UPDATE_LOOPBACK_SHORT_CIRCUITED:
    Worker_Alpha_ComponentUpdateLoopback = 1;
/// Enum defining the possible modes of Loopback when updating a component.
pub type Worker_Alpha_ComponentUpdateLoopback = u32;
/// Parameters for sending a log message to SpatialOS.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LogMessage {
    /// The severity of the log message; defined in the Worker_LogLevel enumeration.
    pub level: u8,
    /// The name of the logger.
    pub logger_name: *const ::std::os::raw::c_char,
    /// The full log message.
    pub message: *const ::std::os::raw::c_char,
    /// The ID of the entity this message relates to, or NULL for none.
    pub entity_id: *const Worker_EntityId,
}
/// Parameters for a gauge metric.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_GaugeMetric {
    pub key: *const ::std::os::raw::c_char,
    pub value: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_HistogramMetricBucket {
    pub upper_bound: f64,
    pub samples: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_HistogramMetric {
    pub key: *const ::std::os::raw::c_char,
    pub sum: f64,
    pub bucket_count: u32,
    pub buckets: *const Worker_HistogramMetricBucket,
}
/// Parameters for sending metrics to SpatialOS.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Metrics {
    /// The load value of this worker. If NULL, do not report load.
    pub load: *const f64,
    /// The number of gauge metrics.
    pub gauge_metric_count: u32,
    /// Array of gauge metrics.
    pub gauge_metrics: *const Worker_GaugeMetric,
    /// The number of histogram metrics.
    pub histogram_metric_count: u32,
    /// Array of histogram metrics.
    pub histogram_metrics: *const Worker_HistogramMetric,
}
pub type Worker_CommandRequestHandle = ::std::os::raw::c_void;
pub type Worker_CommandResponseHandle = ::std::os::raw::c_void;
pub type Worker_ComponentDataHandle = ::std::os::raw::c_void;
pub type Worker_ComponentUpdateHandle = ::std::os::raw::c_void;
pub type Worker_CommandRequestFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandRequestHandle,
    ),
>;
pub type Worker_CommandResponseFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandResponseHandle,
    ),
>;
pub type Worker_ComponentDataFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentDataHandle,
    ),
>;
pub type Worker_ComponentUpdateFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentUpdateHandle,
    ),
>;
pub type Worker_CommandRequestCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandRequestHandle,
    ) -> *mut Worker_CommandRequestHandle,
>;
pub type Worker_CommandResponseCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandResponseHandle,
    ) -> *mut Worker_CommandResponseHandle,
>;
pub type Worker_ComponentDataCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentDataHandle,
    ) -> *mut Worker_ComponentDataHandle,
>;
pub type Worker_ComponentUpdateCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentUpdateHandle,
    ) -> *mut Worker_ComponentUpdateHandle,
>;
pub type Worker_CommandRequestDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_CommandRequest,
        handle_out: *mut *mut Worker_CommandRequestHandle,
    ) -> u8,
>;
pub type Worker_CommandResponseDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_CommandResponse,
        handle_out: *mut *mut Worker_CommandResponseHandle,
    ) -> u8,
>;
pub type Worker_ComponentDataDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_ComponentData,
        handle_out: *mut *mut Worker_ComponentDataHandle,
    ) -> u8,
>;
pub type Worker_ComponentUpdateDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_ComponentUpdate,
        handle_out: *mut *mut Worker_ComponentUpdateHandle,
    ) -> u8,
>;
pub type Worker_CommandRequestSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandRequestHandle,
        target_out: *mut *mut Schema_CommandRequest,
    ),
>;
pub type Worker_CommandResponseSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandResponseHandle,
        target_out: *mut *mut Schema_CommandResponse,
    ),
>;
pub type Worker_ComponentDataSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentDataHandle,
        target_out: *mut *mut Schema_ComponentData,
    ),
>;
pub type Worker_ComponentUpdateSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentUpdateHandle,
        target_out: *mut *mut Schema_ComponentUpdate,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentVtable {
    /// Component ID that this vtable is for. If this is the default vtable, this field is ignored.
    pub component_id: Worker_ComponentId,
    /// User data which will be passed directly to the callbacks supplied below.
    pub user_data: *mut ::std::os::raw::c_void,
    pub command_request_free: Worker_CommandRequestFree,
    pub command_request_copy: Worker_CommandRequestCopy,
    pub command_request_deserialize: Worker_CommandRequestDeserialize,
    pub command_request_serialize: Worker_CommandRequestSerialize,
    pub command_response_free: Worker_CommandResponseFree,
    pub command_response_copy: Worker_CommandResponseCopy,
    pub command_response_deserialize: Worker_CommandResponseDeserialize,
    pub command_response_serialize: Worker_CommandResponseSerialize,
    pub component_data_free: Worker_ComponentDataFree,
    pub component_data_copy: Worker_ComponentDataCopy,
    pub component_data_deserialize: Worker_ComponentDataDeserialize,
    pub component_data_serialize: Worker_ComponentDataSerialize,
    pub component_update_free: Worker_ComponentUpdateFree,
    pub component_update_copy: Worker_ComponentUpdateCopy,
    pub component_update_deserialize: Worker_ComponentUpdateDeserialize,
    pub component_update_serialize: Worker_ComponentUpdateSerialize,
}
/// An object used to represent a command request by either raw schema data or some user-defined
/// handle type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandRequest {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_CommandRequest,
    pub user_handle: *mut Worker_CommandRequestHandle,
}
/// An object used to represent a command response by either raw schema data or some user-defined
/// handle type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandResponse {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_CommandResponse,
    pub user_handle: *mut Worker_CommandResponseHandle,
}
/// An object used to represent a component data snapshot by either raw schema data or some
/// user-defined handle type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentData {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_ComponentData,
    pub user_handle: *mut Worker_ComponentDataHandle,
}
/// An object used to represent a component update by either raw schema data or some user-defined
/// handle type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentUpdate {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_ComponentUpdate,
    pub user_handle: *mut Worker_ComponentUpdateHandle,
}
extern "C" {
    /// Acquire a reference to extend the lifetime of a command request owned by the SDK.
    pub fn Worker_AcquireCommandRequest(
        request: *const Worker_CommandRequest,
    ) -> *mut Worker_CommandRequest;
}
extern "C" {
    /// Acquire a reference to extend the lifetime of a command response owned by the SDK.
    pub fn Worker_AcquireCommandResponse(
        response: *const Worker_CommandResponse,
    ) -> *mut Worker_CommandResponse;
}
extern "C" {
    /// Acquire a reference to extend the lifetime of a component data snapshot owned by the SDK.
    pub fn Worker_AcquireComponentData(
        data: *const Worker_ComponentData,
    ) -> *mut Worker_ComponentData;
}
extern "C" {
    /// Acquire a reference to extend the lifetime of a component update owned by the SDK.
    pub fn Worker_AcquireComponentUpdate(
        update: *const Worker_ComponentUpdate,
    ) -> *mut Worker_ComponentUpdate;
}
extern "C" {
    /// Release a reference obtained by Worker_AcquireCommandRequest.
    pub fn Worker_ReleaseCommandRequest(request: *mut Worker_CommandRequest);
}
extern "C" {
    /// Release a reference obtained by Worker_AcquireCommandResponse.
    pub fn Worker_ReleaseCommandResponse(response: *mut Worker_CommandResponse);
}
extern "C" {
    /// Release a reference obtained by Worker_AcquireComponentData.
    pub fn Worker_ReleaseComponentData(data: *mut Worker_ComponentData);
}
extern "C" {
    /// Release a reference obtained by Worker_AcquireComponentUpdate.
    pub fn Worker_ReleaseComponentUpdate(update: *mut Worker_ComponentUpdate);
}
/// Represents an entity with an ID and a component data snapshot.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Entity {
    /// The ID of the entity.
    pub entity_id: Worker_EntityId,
    /// Number of components for the entity.
    pub component_count: u32,
    /// Array of initial component data for the entity.
    pub components: *const Worker_ComponentData,
}
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_ENTITY_ID: Worker_ConstraintType = 1;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_COMPONENT: Worker_ConstraintType = 2;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_SPHERE: Worker_ConstraintType = 3;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_AND: Worker_ConstraintType = 4;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_OR: Worker_ConstraintType = 5;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_NOT: Worker_ConstraintType = 6;
pub type Worker_ConstraintType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_EntityIdConstraint {
    pub entity_id: Worker_EntityId,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentConstraint {
    pub component_id: Worker_ComponentId,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SphereConstraint {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub radius: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_AndConstraint {
    pub constraint_count: u32,
    pub constraints: *mut Worker_Constraint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_OrConstraint {
    pub constraint_count: u32,
    pub constraints: *mut Worker_Constraint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_NotConstraint {
    pub constraint: *mut Worker_Constraint,
}
/// A single query constraint.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Worker_Constraint {
    /// The type of constraint, defined using Worker_ConstraintType.
    pub constraint_type: u8,
    pub __bindgen_anon_1: Worker_Constraint__bindgen_ty_1,
}
/// Union with fields corresponding to each constraint type.
#[repr(C)]
#[derive(Copy, Clone)]
pub union Worker_Constraint__bindgen_ty_1 {
    pub entity_id_constraint: Worker_EntityIdConstraint,
    pub component_constraint: Worker_ComponentConstraint,
    pub sphere_constraint: Worker_SphereConstraint,
    pub and_constraint: Worker_AndConstraint,
    pub or_constraint: Worker_OrConstraint,
    pub not_constraint: Worker_NotConstraint,
    _bindgen_union_align: [u64; 4usize],
}
pub const Worker_ResultType_WORKER_RESULT_TYPE_COUNT: Worker_ResultType = 1;
pub const Worker_ResultType_WORKER_RESULT_TYPE_SNAPSHOT: Worker_ResultType = 2;
pub type Worker_ResultType = u32;
/// An entity query.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Worker_EntityQuery {
    /// The constraint for this query.
    pub constraint: Worker_Constraint,
    /// Result type for this query, using Worker_ResultType.
    pub result_type: u8,
    /// Number of component IDs in the array for a snapshot result type.
    pub snapshot_result_type_component_id_count: u32,
    /// Pointer to component ID data for a snapshot result type. NULL means all component IDs.
    pub snapshot_result_type_component_ids: *const Worker_ComponentId,
}
/// An interest override for a particular (entity ID, component ID) pair.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_InterestOverride {
    /// The ID of the component for which interest is being overridden.
    pub component_id: u32,
    /// Whether the worker is interested in this component.
    pub is_interested: u8,
}
/// Worker attributes that are part of a worker's runtime configuration.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_WorkerAttributes {
    /// Number of worker attributes.
    pub attribute_count: u32,
    /// Will be NULL if there are no attributes associated with the worker.
    pub attributes: *mut *const ::std::os::raw::c_char,
}
/// Data for a disconnect message from the SDK.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DisconnectOp {
    /// A value from the Worker_ConnectionStatusCode enumeration.
    pub connection_status_code: u8,
    /// A string giving detailed information on the reason for disconnecting.
    pub reason: *const ::std::os::raw::c_char,
}
/// Data for a FlagUpdate operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_FlagUpdateOp {
    /// The name of the updated worker flag.
    pub name: *const ::std::os::raw::c_char,
    /// The new value of the updated worker flag.
    /// A null value indicates that the flag has been deleted.
    pub value: *const ::std::os::raw::c_char,
}
/// Data for a log message from the SDK.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LogMessageOp {
    /// The severity of the log message; defined in the Worker_LogLevel enumeration.
    pub level: u8,
    /// The message.
    pub message: *const ::std::os::raw::c_char,
}
/// Data for a set of built-in metrics reported by the SDK.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_MetricsOp {
    pub metrics: Worker_Metrics,
}
/// Data for a critical section boundary (enter or leave) operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CriticalSectionOp {
    /// Whether the protocol is entering a critical section (true) or leaving it (false).
    pub in_critical_section: u8,
}
/// Data for an AddEntity operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_AddEntityOp {
    /// The ID of the entity that was added to the worker's view of the simulation.
    pub entity_id: Worker_EntityId,
}
/// Data for a RemoveEntity operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_RemoveEntityOp {
    /// The ID of the entity that was removed from the worker's view of the simulation.
    pub entity_id: Worker_EntityId,
}
/// Data for a ReserveEntityIdResponse operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ReserveEntityIdResponseOp {
    /// The ID of the reserve entity ID request for which there was a response.
    pub request_id: Worker_RequestId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
    /// If successful, newly allocated entity id which is guaranteed to be unused in the current
    /// deployment.
    pub entity_id: Worker_EntityId,
}
/// Data for a ReserveEntityIdsResponse operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ReserveEntityIdsResponseOp {
    /// The ID of the reserve entity ID request for which there was a response.
    pub request_id: Worker_RequestId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
    /// If successful, an ID which is the first in a contiguous range of newly allocated entity
    /// IDs which are guaranteed to be unused in the current deployment.
    pub first_entity_id: Worker_EntityId,
    /// If successful, the number of IDs reserved in the contiguous range, otherwise 0.
    pub number_of_entity_ids: u32,
}
/// Data for a CreateEntity operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CreateEntityResponseOp {
    /// The ID of the request for which there was a response.
    pub request_id: Worker_RequestId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
    /// If successful, the entity ID of the newly created entity.
    pub entity_id: Worker_EntityId,
}
/// Data for a DeleteEntity operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DeleteEntityResponseOp {
    /// The ID of the delete entity request for which there was a command response.
    pub request_id: Worker_RequestId,
    /// The ID of the target entity of this request.
    pub entity_id: Worker_EntityId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
}
/// A response indicating the result of an entity query request.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_EntityQueryResponseOp {
    /// The ID of the entity query request for which there was a response.
    pub request_id: Worker_RequestId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
    /// Number of entities in the result set. Reused to indicate the result itself for CountResultType
    /// queries.
    pub result_count: u32,
    /// Array of entities in the result set. Will be NULL if the query was a count query. Snapshot data
    /// in the result is deserialized with the corresponding vtable Deserialize function and freed with
    /// the vtable Free function when the OpList is destroyed.
    pub results: *const Worker_Entity,
}
/// Data for an AddComponent operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_AddComponentOp {
    /// The ID of the entity for which a component was added.
    pub entity_id: Worker_EntityId,
    /// The initial data for the new component. Deserialized with the corresponding vtable Deserialize
    /// function and freed with the vtable Free function when the OpList is destroyed.
    pub data: Worker_ComponentData,
}
/// Data for a RemoveComponent operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_RemoveComponentOp {
    /// The ID of the entity for which a component was removed.
    pub entity_id: Worker_EntityId,
    /// The ID of the component that was removed.
    pub component_id: Worker_ComponentId,
}
/// Data for an AuthorityChange operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_AuthorityChangeOp {
    /// The ID of the entity for which there was an authority change.
    pub entity_id: Worker_EntityId,
    /// The ID of the component over which the worker's authority has changed.
    pub component_id: Worker_ComponentId,
    /// The authority state of the component, using the Worker_Authority enumeration.
    pub authority: u8,
}
/// Data for a ComponentUpdate operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentUpdateOp {
    /// The ID of the entity for which there was a component update.
    pub entity_id: Worker_EntityId,
    /// The new component data for the updated entity. Deserialized with the corresponding vtable
    /// Deserialize function and freed with the vtable Free function when the OpList is destroyed.
    pub update: Worker_ComponentUpdate,
}
/// Data for a CommandRequest operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandRequestOp {
    /// The incoming command request ID.
    pub request_id: Worker_RequestId,
    /// The ID of the entity for which there was a command request.
    pub entity_id: Worker_EntityId,
    /// Upper bound on request timeout provided by the platform.
    pub timeout_millis: u32,
    /// The ID of the worker that sent the request.
    pub caller_worker_id: *const ::std::os::raw::c_char,
    /// The attributes of the worker that sent the request.
    pub caller_attribute_set: Worker_WorkerAttributes,
    /// The command request data. Deserialized with the corresponding vtable Deserialize function and
    /// freed with the vtable Free function when the OpList is destroyed.
    pub request: Worker_CommandRequest,
}
/// Data for a CommandResponse operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandResponseOp {
    /// The ID of the command request for which there was a command response.
    pub request_id: Worker_RequestId,
    /// The ID of the entity originally targeted by the command request.
    pub entity_id: Worker_EntityId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
    /// The command response data. Deserialized with the corresponding vtable Deserialize function and
    /// freed with the vtable Free function when the OpList is destroyed.
    pub response: Worker_CommandResponse,
    /// The command ID given to Worker_Connection_SendCommandRequest.
    pub command_id: u32,
}
pub const Worker_OpType_WORKER_OP_TYPE_DISCONNECT: Worker_OpType = 1;
pub const Worker_OpType_WORKER_OP_TYPE_FLAG_UPDATE: Worker_OpType = 2;
pub const Worker_OpType_WORKER_OP_TYPE_LOG_MESSAGE: Worker_OpType = 3;
pub const Worker_OpType_WORKER_OP_TYPE_METRICS: Worker_OpType = 4;
pub const Worker_OpType_WORKER_OP_TYPE_CRITICAL_SECTION: Worker_OpType = 5;
pub const Worker_OpType_WORKER_OP_TYPE_ADD_ENTITY: Worker_OpType = 6;
pub const Worker_OpType_WORKER_OP_TYPE_REMOVE_ENTITY: Worker_OpType = 7;
pub const Worker_OpType_WORKER_OP_TYPE_RESERVE_ENTITY_ID_RESPONSE: Worker_OpType = 8;
pub const Worker_OpType_WORKER_OP_TYPE_RESERVE_ENTITY_IDS_RESPONSE: Worker_OpType = 9;
pub const Worker_OpType_WORKER_OP_TYPE_CREATE_ENTITY_RESPONSE: Worker_OpType = 10;
pub const Worker_OpType_WORKER_OP_TYPE_DELETE_ENTITY_RESPONSE: Worker_OpType = 11;
pub const Worker_OpType_WORKER_OP_TYPE_ENTITY_QUERY_RESPONSE: Worker_OpType = 12;
pub const Worker_OpType_WORKER_OP_TYPE_ADD_COMPONENT: Worker_OpType = 13;
pub const Worker_OpType_WORKER_OP_TYPE_REMOVE_COMPONENT: Worker_OpType = 14;
pub const Worker_OpType_WORKER_OP_TYPE_AUTHORITY_CHANGE: Worker_OpType = 15;
pub const Worker_OpType_WORKER_OP_TYPE_COMPONENT_UPDATE: Worker_OpType = 16;
pub const Worker_OpType_WORKER_OP_TYPE_COMMAND_REQUEST: Worker_OpType = 17;
pub const Worker_OpType_WORKER_OP_TYPE_COMMAND_RESPONSE: Worker_OpType = 18;
/// Enum defining different possible op types.
pub type Worker_OpType = u32;
/// Data for a single op contained within an op list.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Worker_Op {
    /// The type of this op, defined in Worker_OpType.
    pub op_type: u8,
    pub __bindgen_anon_1: Worker_Op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Worker_Op__bindgen_ty_1 {
    pub disconnect: Worker_DisconnectOp,
    pub flag_update: Worker_FlagUpdateOp,
    pub log_message: Worker_LogMessageOp,
    pub metrics: Worker_MetricsOp,
    pub critical_section: Worker_CriticalSectionOp,
    pub add_entity: Worker_AddEntityOp,
    pub remove_entity: Worker_RemoveEntityOp,
    pub reserve_entity_id_response: Worker_ReserveEntityIdResponseOp,
    pub reserve_entity_ids_response: Worker_ReserveEntityIdsResponseOp,
    pub create_entity_response: Worker_CreateEntityResponseOp,
    pub delete_entity_response: Worker_DeleteEntityResponseOp,
    pub entity_query_response: Worker_EntityQueryResponseOp,
    pub add_component: Worker_AddComponentOp,
    pub remove_component: Worker_RemoveComponentOp,
    pub authority_change: Worker_AuthorityChangeOp,
    pub component_update: Worker_ComponentUpdateOp,
    pub command_request: Worker_CommandRequestOp,
    pub command_response: Worker_CommandResponseOp,
    _bindgen_union_align: [u64; 10usize],
}
/// An op list, usually returned by Worker_Connection_GetOpList.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_OpList {
    pub ops: *mut Worker_Op,
    pub op_count: u32,
}
/// Parameters for configuring a RakNet connection. Used by Worker_NetworkParameters.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_RakNetNetworkParameters {
    /// Time (in milliseconds) that RakNet should use for its heartbeat protocol.
    pub heartbeat_timeout_millis: u32,
}
/// Parameters for configuring a TCP connection. Used by Worker_NetworkParameters.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_TcpNetworkParameters {
    /// The number of multiplexed TCP connections to use.
    pub multiplex_level: u8,
    /// Size in bytes of the TCP send buffer.
    pub send_buffer_size: u32,
    /// Size in bytes of the TCP receive buffer.
    pub receive_buffer_size: u32,
    /// Whether to enable TCP_NODELAY.
    pub no_delay: u8,
}
/// Parameters to configure erasure coding, a forward error correction technique which
/// increases bandwidth usage but may improve latency on unreliable networks.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_ErasureCodecParameters {
    /// Number of consecutive packets to send before sending redundant recovery packets.
    pub original_packet_count: u8,
    /// Number of redundant recovery packets to send for each group of consecutive original
    /// packets. These packets are used to recover up to the same number of lost original packets.
    pub recovery_packet_count: u8,
    /// Number of batches that can be stored in memory, where a batch contains packets belonging to
    /// the same group of consecutive original packets and the corresponding recovery packets. Each
    /// batch contains up to OriginalPacketCount plus RecoveryPacketCount packets.
    pub window_size: u8,
}
/// Parameters to configure internal heartbeating which can detect unresponsive peers. If an
/// unresponsive peer is detected, a Worker_DisconnectOp will be enqueued in the op list.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_HeartbeatParameters {
    /// Minimum interval, in milliseconds, between which heartbeat messages are sent to the
    /// peer. A new heartbeat won't be sent before a response for the original heartbeat is received.
    pub interval_millis: u64,
    /// Time, in milliseconds, after which the peer will be deemed unresponsive.
    pub timeout_millis: u64,
}
/// Parameters for configuring a KCP connection. Used by Worker_NetworkParameters.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_KcpNetworkParameters {
    /// Whether to enable fast retransmission, which causes retransmission delays to increase more
    /// slowly when retransmitting timed out packets multiple times.
    pub fast_retransmission: u8,
    /// Whether to enable early retransmission, which causes optimistic retransmission of earlier
    /// packets when acknowledgements are received for packets which were sent later, rather than
    /// waiting until the retransmission timeout has expired.
    pub early_retransmission: u8,
    /// Whether to enable non-concessional flow control, which disables the usage of
    /// congestion windows (which are used to reduce packet loss across congested networks).
    /// Enabling non-concessional flow control can help optimize for low-latency delivery of
    /// small messages.
    pub non_concessional_flow_control: u8,
    /// Number of multiplexed KCP streams.
    pub multiplex_level: u32,
    /// Interval, in milliseconds, between which the KCP transport layer sends and receives
    /// packets waiting in its send and receive buffers respectively.
    pub update_interval_millis: u32,
    /// Hard limit on the minimum retransmission timeout. A packet will be resent if an
    /// acknowledgment has not been received from the peer within a time period known as the
    /// retransmission timeout. The retransmission timeout is calculated based on estimated round
    /// trip times to the remote peer, but it will never be set to a value lower than the minimum
    /// retransmission timeout. If you set this parameter to a value which is much higher than the
    /// average round trip time to a peer, it will likely result in packets not being resent
    /// as early as they could be, increasing latency for retransmitted packets. However, if you set
    /// this parameter to a value which is lower than the average round trip time (or ping), packets
    /// will be retransmitted even if they are not lost, which will cause unnecessary bandwidth
    /// overhead until round trip times are calculated. For more information on retransmission
    /// timeouts and their calculation, see https://tools.ietf.org/html/rfc6298. Note,
    /// however, that the RFC pertains to TCP, and therefore it focuses on avoiding unnecessary
    /// retransmissions rather than optimizing for latency.
    /// Set to zero to use default, which is lower when
    /// Worker_Alpha_KcpNetworkParameters::fast_retransmisssion is enabled.
    pub min_rto_millis: u32,
    /// KCP flow-control window size, in number of packets. The window applies to sending
    /// across all streams. This means that messages being sent to the remote peer will be delayed if
    /// there are Worker_Alpha_KcpNetworkParameters::window_size packets still waiting to be
    /// acknowledged by the peer. The same window also applies to receiving packets, but it only
    /// applies to each KCP stream independently. This limits the rate at which a peer sends data.
    /// However, it does not bound the total memory that may be used by KCP internally for buffering
    /// incoming messages in the way it does for outgoing messages.
    pub window_size: u32,
    /// Whether to enable the erasure codec.
    pub enable_erasure_codec: u8,
    /// Erasure codec parameters.
    pub erasure_codec: Worker_Alpha_ErasureCodecParameters,
    /// Heartbeat parameters.
    pub heartbeat: Worker_Alpha_HeartbeatParameters,
}
/// Use this flag to connect over TCP.
pub const Worker_NetworkConnectionType_WORKER_NETWORK_CONNECTION_TYPE_TCP:
    Worker_NetworkConnectionType = 0;
/// Use this flag to connect over RakNet.
pub const Worker_NetworkConnectionType_WORKER_NETWORK_CONNECTION_TYPE_RAKNET:
    Worker_NetworkConnectionType = 1;
/// Use this flag to connect over KCP.
pub const Worker_NetworkConnectionType_WORKER_NETWORK_CONNECTION_TYPE_KCP:
    Worker_NetworkConnectionType = 2;
/// Network connection type used by the Worker_NetworkParameters struct.
pub type Worker_NetworkConnectionType = u32;
/// Parameters for configuring the network connection.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_NetworkParameters {
    /// Set this flag to non-zero to connect to SpatialOS using the externally-visible IP address. This
    /// flag must be set when connecting externally (i.e. from outside the cloud) to a cloud
    /// deployment.
    pub use_external_ip: u8,
    /// Type of network connection to use when connecting to SpatialOS, defined in
    /// Worker_NetworkConnectionType.
    pub connection_type: u8,
    /// Parameters used if the WORKER_NETWORK_RAKNET flag is set.
    pub raknet: Worker_RakNetNetworkParameters,
    /// Parameters used if the WORKER_NETWORK_TCP flag is set.
    pub tcp: Worker_TcpNetworkParameters,
    /// Parameters used if the WORKER_NETWORK_KCP flag is set.
    pub kcp: Worker_Alpha_KcpNetworkParameters,
    /// Timeout for the connection to SpatialOS to be established.
    pub connection_timeout_millis: u64,
    /// Default timeout for worker commands if one is not specified when command is sent.
    pub default_command_timeout_millis: u32,
}
/// Tuning parameters for configuring protocol logging in the SDK. Used by
/// Worker_ConnectionParameters.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ProtocolLoggingParameters {
    /// Log file names are prefixed with this prefix, are numbered, and have the extension .log.
    pub log_prefix: *const ::std::os::raw::c_char,
    /// Maximum number of log files to keep. Note that logs from any previous protocol logging
    /// sessions will be overwritten.
    pub max_log_files: u32,
    /// Once the size of a log file reaches this size, a new log file is created.
    pub max_log_file_size_bytes: u32,
}
/// Parameters for configuring thread affinity. Affinity masks are bit masks where
/// having 1 in the nth least significant position means the thread will be permitted to run
/// on the nth core. If an affinity mask is set to zero, the group of threads using that mask
/// will have no thread affinity. Used by Worker_ConnectionParameters.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ThreadAffinityParameters {
    /// Affinity mask for threads related to receiving network ops.
    pub receive_threads_affinity_mask: u64,
    /// Affinity mask for threads related to sending network ops.
    pub send_threads_affinity_mask: u64,
    /// Affinity mask for short-lived threads.
    pub temporary_threads_affinity_mask: u64,
}
/// Parameters for creating a Worker_Connection and connecting to SpatialOS.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ConnectionParameters {
    /// Worker type (platform).
    pub worker_type: *const ::std::os::raw::c_char,
    /// Network parameters.
    pub network: Worker_NetworkParameters,
    /// Number of messages that can be stored on the send queue. When the send queue is full, calls to
    /// Worker_Connection_Send functions can block.
    pub send_queue_capacity: u32,
    /// Number of messages that can be stored on the receive queue. When the receive queue is full,
    /// SpatialOS can apply QoS and drop messages to the worker.
    pub receive_queue_capacity: u32,
    /// Number of messages logged by the SDK that can be stored in the log message queue. When the log
    /// message queue is full, messages logged by the SDK can be dropped.
    pub log_message_queue_capacity: u32,
    /// The Connection tracks several internal metrics, such as send and receive queue statistics. This
    /// parameter controls how frequently the Connection will return a MetricsOp reporting its built-in
    /// metrics. If set to zero, this functionality is disabled.
    pub built_in_metrics_report_period_millis: u32,
    /// Parameters for configuring protocol parameters.
    pub protocol_logging: Worker_ProtocolLoggingParameters,
    /// Whether to enable protocol logging at startup.
    pub enable_protocol_logging_at_startup: u8,
    /// Parameters for configuring thread affinity.
    pub thread_affinity: Worker_ThreadAffinityParameters,
    /// Number of component vtables.
    pub component_vtable_count: u32,
    /// Component vtable for each component that the connection will deal with.
    pub component_vtables: *const Worker_ComponentVtable,
    /// Default vtable used when a component is not registered. Only used if not NULL.
    pub default_component_vtable: *const Worker_ComponentVtable,
}
/// Parameters for authenticating using a SpatialOS login token.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LoginTokenCredentials {
    /// The token would typically be provided on the command-line by the SpatialOS launcher.
    pub token: *const ::std::os::raw::c_char,
}
/// Parameters for authenticating using Steam credentials.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SteamCredentials {
    /// Steam ticket for the steam app ID and publisher key corresponding to the project name specified
    /// in the Worker_LocatorParameters. Typically obtained from the steam APIs.
    pub ticket: *const ::std::os::raw::c_char,
    /// Deployment tag to request access for. If non-empty, must match the following regex:
    /// [A-Za-z0-9][A-Za-z0-9_]*
    pub deployment_tag: *const ::std::os::raw::c_char,
}
/// Parameters for authenticating using a Player Identity Token and Login Token.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_PlayerIdentityCredentials {
    /// Authenticates a user to a single deployment. Obtained from a game authentication server using
    /// a PIT.
    pub player_identity_token: *const ::std::os::raw::c_char,
    /// Uniquely identifies a user across deployments, and is provided by a game authentication
    /// server.
    pub login_token: *const ::std::os::raw::c_char,
}
pub const Worker_LocatorCredentialsTypes_WORKER_LOCATOR_LOGIN_TOKEN_CREDENTIALS:
    Worker_LocatorCredentialsTypes = 1;
pub const Worker_LocatorCredentialsTypes_WORKER_LOCATOR_STEAM_CREDENTIALS:
    Worker_LocatorCredentialsTypes = 2;
/// Locator credentials type used by the Worker_LocatorParameters struct.
pub type Worker_LocatorCredentialsTypes = u32;
/// Parameters for authenticating and logging in to a SpatialOS deployment.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LocatorParameters {
    /// The name of the SpatialOS project.
    pub project_name: *const ::std::os::raw::c_char,
    /// Type of credentials to use when authenticating via the Locator, defined in
    /// Worker_LocatorCredentialsTypes
    pub credentials_type: u8,
    /// Parameters used if the WORKER_LOGIN_TOKEN_CREDENTIALS flag is set.
    pub login_token: Worker_LoginTokenCredentials,
    /// Parameters used if the WORKER_STEAM_CREDENTIALS flag is set.
    pub steam: Worker_SteamCredentials,
    /// Parameters for configuring logging.
    pub logging: Worker_ProtocolLoggingParameters,
    /// Whether to enable logging for the Locator flow.
    pub enable_logging: u8,
}
/// Parameters for authenticating and logging in to a SpatialOS deployment using player identity
/// credentials.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_LocatorParameters {
    /// The player identity token/login token pair used for authentication.
    pub player_identity: Worker_Alpha_PlayerIdentityCredentials,
    /// Whether to use an insecure (non-TLS) connection for local development.
    pub use_insecure_connection: u8,
    /// Parameters for configuring logging.
    pub logging: Worker_ProtocolLoggingParameters,
    /// Whether to enable logging for the Locator flow.
    pub enable_logging: u8,
}
/// Details of a specific deployment obtained via Worker_Locator_GetDeploymentListAsync.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Deployment {
    /// Name of the deployment.
    pub deployment_name: *const ::std::os::raw::c_char,
    /// The name of the assembly used by this deployment.
    pub assembly_name: *const ::std::os::raw::c_char,
    /// Description of the deployment.
    pub description: *const ::std::os::raw::c_char,
    /// Number of users currently connected to the deployment.
    pub users_connected: u32,
    /// Total user capacity of the deployment.
    pub users_capacity: u32,
}
/// A deployment list obtained via Worker_Locator_GetDeploymentListAsync.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DeploymentList {
    /// Number of deployments.
    pub deployment_count: u32,
    /// Array of deployments.
    pub deployments: *mut Worker_Deployment,
    /// Will be non-NULL if an error occurred.
    pub error: *const ::std::os::raw::c_char,
}
/// A queue status update when connecting to a deployment via Worker_Locator_ConnectAsync.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_QueueStatus {
    /// Position in the queue. Decreases as we advance to the front of the queue.
    pub position_in_queue: u32,
    /// Will be non-NULL if an error occurred.
    pub error: *const ::std::os::raw::c_char,
}
/// Component update parameters. Used to modify the behaviour of a component update request.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_UpdateParameters {
    /// Controls how the update is sent back to the worker from which it was sent. Defined in the
    /// Worker_ComponentUpdateLoopback enumeration.
    pub loopback: u8,
}
/// Command parameters. Used to modify the behaviour of a command request.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandParameters {
    /// Allow command requests to bypass the bridge when this worker is authoritative over the target
    /// entity-component.
    pub allow_short_circuit: u8,
}
/// The parameters used when creating a player identity token.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_PlayerIdentityTokenRequest {
    /// The ID of the development authentication token used for exchanging the player identity token.
    pub development_authentication_token_id: *const ::std::os::raw::c_char,
    /// The ID of the player we are generating a PIT for.
    pub player_id: *const ::std::os::raw::c_char,
    /// The lifetime duration of the requested PIT. This is an optional field.
    /// If the pointer is null, a default value of 24 hours will be used.
    pub duration_seconds: *mut u32,
    /// The player's display name.
    pub display_name: *const ::std::os::raw::c_char,
    /// Additional metadata that can be stored in the PIT.
    pub metadata: *const ::std::os::raw::c_char,
    /// Whether to use an insecure (non-TLS) connection for local development.
    pub use_insecure_connection: u8,
}
/// The result of creating a player identity token.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_PlayerIdentityTokenResponse {
    /// The returned player identity token.
    pub player_identity_token: *const ::std::os::raw::c_char,
    /// The status of the request. This value is a member of the enum Worker_ConnectionStatusCode.
    pub connection_status_code: u8,
    /// Will be non-NULL if an error occurred.
    pub error: *const ::std::os::raw::c_char,
}
/// The parameters used when creating a login token.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_LoginTokensRequest {
    /// The player identity token of the player
    pub player_identity_token: *const ::std::os::raw::c_char,
    /// The worker type for which the requested LTs are scoped for.
    pub worker_type: *const ::std::os::raw::c_char,
    /// The lifetime duration of the requested LTs. This is an optional field.
    /// If the pointer is null, a default value of 15 minutes will be used.
    pub duration_seconds: *mut u32,
    /// Whether to use an insecure (non-TLS) connection for local development.
    pub use_insecure_connection: u8,
}
/// A single login token with additional details.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_LoginTokenDetails {
    /// The UUID of the deployment.
    pub deployment_id: *const ::std::os::raw::c_char,
    /// The name of the deployment
    pub deployment_name: *const ::std::os::raw::c_char,
    /// The number of tags that the deployment contains.
    pub tag_count: u32,
    /// The tags that the deployment contains.
    pub tags: *mut *const ::std::os::raw::c_char,
    /// The generated login token for this deployment.
    pub login_token: *const ::std::os::raw::c_char,
}
/// A login token list obtained via Worker_Alpha_CreateDevelopmentLoginTokens
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_LoginTokensResponse {
    /// Number of login tokens.
    pub login_token_count: u32,
    /// Array of login tokens.
    pub login_tokens: *mut Worker_Alpha_LoginTokenDetails,
    /// The status of the request. This value is a member of the enum Worker_ConnectionStatusCode.
    pub connection_status_code: u8,
    /// Will be non-NULL if an error occurred.
    pub error: *const ::std::os::raw::c_char,
}
/// Locator callback typedef.
pub type Worker_DeploymentListCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        deployment_list: *const Worker_DeploymentList,
    ),
>;
/// Locator callback typedef.
pub type Worker_QueueStatusCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        queue_status: *const Worker_QueueStatus,
    ) -> u8,
>;
/// PIT-creation callback typedef.
pub type Worker_Alpha_PlayerIdentityTokenResponseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        response: *const Worker_Alpha_PlayerIdentityTokenResponse,
    ),
>;
/// login token-creation callback typedef.
pub type Worker_Alpha_LoginTokensResponseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        response: *const Worker_Alpha_LoginTokensResponse,
    ),
>;
/// Worker flags callback typedef.
pub type Worker_GetFlagCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_char,
    ),
>;
pub type AllocateFunction = ::std::option::Option<
    unsafe extern "C" fn(
        size: usize,
        state: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type DeallocateFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pointer: *mut ::std::os::raw::c_void,
        size: usize,
        state: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Set custom allocation functions and state for managing memory within the API.
    /// The allocation function should allocate a block of memory of the size that is given by
    /// the argument and return a pointer to the first byte.
    /// The pointer must be suitably aligned to hold an object of any fundamental alignment and
    /// will be released by a matching call to the deallocation function with the same size.
    /// If either allocation or deallocation function throws, the application will terminate.
    /// Both allocation and deallocation functions must be thread-safe.
    ///
    /// You must call Worker_SetAllocator once before any other API calls. Calling it
    /// multiple times or after another API call has been made is undefined behaviour.
    pub fn Worker_Alpha_SetAllocator(
        allocate: AllocateFunction,
        deallocate: DeallocateFunction,
        state: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Returns a new Worker_ConnectionParameters with default values set.
    pub fn Worker_DefaultConnectionParameters() -> Worker_ConnectionParameters;
}
extern "C" {
    /// Creates a client which can be used to connect to a SpatialOS deployment via a locator service.
    /// This is the standard flow used to connect a local worker to a cloud deployment.
    ///
    /// The hostname would typically be either "locator.improbable.io" (for production) or
    /// "locator-staging.improbable.io" (for staging).
    pub fn Worker_Locator_Create(
        hostname: *const ::std::os::raw::c_char,
        params: *const Worker_LocatorParameters,
    ) -> *mut Worker_Locator;
}
extern "C" {
    /// Frees resources for a Worker_Locator created with Worker_Locator_Create.
    pub fn Worker_Locator_Destroy(locator: *mut Worker_Locator);
}
extern "C" {
    /// Creates a client which can be used to connect to a SpatialOS deployment via the locator service.
    /// This is the new flow used to connect a local worker to a cloud deployment with a player identity
    /// token and login token.
    /// This object should not be used concurrently by multiple threads.
    pub fn Worker_Alpha_Locator_Create(
        hostname: *const ::std::os::raw::c_char,
        port: u16,
        params: *const Worker_Alpha_LocatorParameters,
    ) -> *mut Worker_Alpha_Locator;
}
extern "C" {
    /// Frees resources for a Worker_Alpha_Locator created with Worker_Alpha_Locator_Create.
    pub fn Worker_Alpha_Locator_Destroy(locator: *mut Worker_Alpha_Locator);
}
extern "C" {
    /// Queries the current list of deployments for the project given in the
    /// Worker_LocatorParameters.
    pub fn Worker_Locator_GetDeploymentListAsync(
        locator: *const Worker_Locator,
    ) -> *mut Worker_DeploymentListFuture;
}
extern "C" {
    /// Connects to a specific deployment. The deployment name should be obtained by calling
    /// Worker_Locator_GetDeploymentListAsync. The callback should return zero to cancel queuing,
    /// or non-zero to continue queueing.
    ///
    /// Returns a Worker_ConnectionFuture that can be used to obtain a Worker_Connection
    /// by using Worker_ConnectionFuture_Get. Caller is responsible for destroying it when no
    /// longer needed by using Worker_ConnectionFuture_Destroy.
    pub fn Worker_Locator_ConnectAsync(
        locator: *const Worker_Locator,
        deployment_name: *const ::std::os::raw::c_char,
        params: *const Worker_ConnectionParameters,
        data: *mut ::std::os::raw::c_void,
        callback: Worker_QueueStatusCallback,
    ) -> *mut Worker_ConnectionFuture;
}
extern "C" {
    /// Connects to a deployment. The deployment is specified in the login token, which is
    /// provided at creation of the Worker_Alpha_Locator in Worker_Alpha_LocatorParameters, along with a
    /// player identity token.
    /// These tokens can be obtained from a game authentication server.
    pub fn Worker_Alpha_Locator_ConnectAsync(
        locator: *const Worker_Alpha_Locator,
        params: *const Worker_ConnectionParameters,
    ) -> *mut Worker_ConnectionFuture;
}
extern "C" {
    /// Connect to a SpatialOS deployment via a receptionist. This is the flow used to connect a managed
    /// worker running in the cloud alongside the deployment, and also to connect any local worker to a
    /// (local or remote) deployment via a locally-running receptionist.
    ///
    /// The hostname and port would typically be provided by SpatialOS on the command-line, if this is a
    /// managed worker on the cloud, or otherwise be predetermined (e.g. localhost:7777 for the default
    /// receptionist of a locally-running deployment).
    ///
    /// Returns a Worker_ConnectionFuture that can be used to obtain a Worker_Connection
    /// by using Worker_ConnectionFuture_Get. Caller is responsible for destroying it when no
    /// longer needed by using Worker_ConnectionFuture_Destroy.
    pub fn Worker_ConnectAsync(
        hostname: *const ::std::os::raw::c_char,
        port: u16,
        worker_id: *const ::std::os::raw::c_char,
        params: *const Worker_ConnectionParameters,
    ) -> *mut Worker_ConnectionFuture;
}
extern "C" {
    /// Destroys a Worker_DeploymentListFuture. Blocks until the future has completed.
    pub fn Worker_DeploymentListFuture_Destroy(future: *mut Worker_DeploymentListFuture);
}
extern "C" {
    /// Gets the result of a Worker_DeploymentListFuture, waiting for up to *timeout_millis to
    /// become available (or forever if timeout_millis is NULL).
    ///
    /// It is an error to call this method again once it has succeeded (e.g. not timed out) once.
    pub fn Worker_DeploymentListFuture_Get(
        future: *mut Worker_DeploymentListFuture,
        timeout_millis: *const u32,
        data: *mut ::std::os::raw::c_void,
        callback: Worker_DeploymentListCallback,
    );
}
extern "C" {
    /// Calls the Development Authentication Service to generate a PIT.
    pub fn Worker_Alpha_CreateDevelopmentPlayerIdentityTokenAsync(
        hostname: *const ::std::os::raw::c_char,
        port: u16,
        params: *mut Worker_Alpha_PlayerIdentityTokenRequest,
    ) -> *mut Worker_Alpha_PlayerIdentityTokenResponseFuture;
}
extern "C" {
    /// Destroys a Worker_Alpha_PlayerIdentityTokenResponseFuture. Blocks until the future has
    /// completed.
    pub fn Worker_Alpha_PlayerIdentityTokenResponseFuture_Destroy(
        future: *mut Worker_Alpha_PlayerIdentityTokenResponseFuture,
    );
}
extern "C" {
    /// Gets the result of a Worker_Alpha_PlayerIdentityTokenResponseFuture, waiting for up to
    /// *timeout_millis to become available (or forever if timeout_millis is NULL).
    ///
    /// It is an error to call this method again once it has succeeded (e.g. not timed out) once.
    pub fn Worker_Alpha_PlayerIdentityTokenResponseFuture_Get(
        future: *mut Worker_Alpha_PlayerIdentityTokenResponseFuture,
        timeout_millis: *const u32,
        data: *mut ::std::os::raw::c_void,
        callback: Worker_Alpha_PlayerIdentityTokenResponseCallback,
    );
}
extern "C" {
    /// Calls the Development Login Service to generate a login token list.
    pub fn Worker_Alpha_CreateDevelopmentLoginTokensAsync(
        hostname: *const ::std::os::raw::c_char,
        port: u16,
        params: *mut Worker_Alpha_LoginTokensRequest,
    ) -> *mut Worker_Alpha_LoginTokensResponseFuture;
}
extern "C" {
    /// Destroys a Worker_Alpha_LoginTokensResponseFuture. Blocks until the future has
    /// completed.
    pub fn Worker_Alpha_LoginTokensResponseFuture_Destroy(
        future: *mut Worker_Alpha_LoginTokensResponseFuture,
    );
}
extern "C" {
    /// Gets the result of a Worker_Alpha_LoginTokensResponseFuture, waiting for up to
    /// *timeout_millis to become available (or forever if timeout_millis is NULL).
    ///
    /// It is an error to call this method again once it has succeeded (e.g. not timeout out) once.
    pub fn Worker_Alpha_LoginTokensResponseFuture_Get(
        future: *mut Worker_Alpha_LoginTokensResponseFuture,
        timeout_millis: *const u32,
        data: *mut ::std::os::raw::c_void,
        callback: Worker_Alpha_LoginTokensResponseCallback,
    );
}
extern "C" {
    /// Destroys a Worker_ConnectionFuture. Blocks until the future has completed.
    pub fn Worker_ConnectionFuture_Destroy(future: *mut Worker_ConnectionFuture);
}
extern "C" {
    /// Gets the result of a Worker_ConnectionFuture, waiting for up to *timeout_millis to
    /// become available (or forever if timeout_millis is NULL). It returns NULL in case of a timeout.
    ///
    /// It is an error to call this method again once it has succeeded (e.g. not timed out) once.
    pub fn Worker_ConnectionFuture_Get(
        future: *mut Worker_ConnectionFuture,
        timeout_millis: *const u32,
    ) -> *mut Worker_Connection;
}
extern "C" {
    /// Frees resources for a Worker_Connection created with Worker_ConnectAsync or
    /// Worker_Locator_ConnectAsync.
    pub fn Worker_Connection_Destroy(connection: *mut Worker_Connection);
}
extern "C" {
    /// Sends a log message from the worker to SpatialOS.
    pub fn Worker_Connection_SendLogMessage(
        connection: *mut Worker_Connection,
        log_message: *const Worker_LogMessage,
    );
}
extern "C" {
    /// Sends metrics data for the worker to SpatialOS.
    pub fn Worker_Connection_SendMetrics(
        connection: *mut Worker_Connection,
        metrics: *const Worker_Metrics,
    );
}
extern "C" {
    /// Requests SpatialOS to reserve an entity ID.
    pub fn Worker_Connection_SendReserveEntityIdRequest(
        connection: *mut Worker_Connection,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Requests SpatialOS to reserve multiple entity IDs.
    pub fn Worker_Connection_SendReserveEntityIdsRequest(
        connection: *mut Worker_Connection,
        number_of_entity_ids: u32,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Requests SpatialOS to create an entity. The entity data is serialized immediately using the
    /// corresponding vtable Serialize function; no copy is made or ownership transferred.
    pub fn Worker_Connection_SendCreateEntityRequest(
        connection: *mut Worker_Connection,
        component_count: u32,
        components: *const Worker_ComponentData,
        entity_id: *const Worker_EntityId,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Requests SpatialOS to delete an entity.
    pub fn Worker_Connection_SendDeleteEntityRequest(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Queries SpatialOS for entity data.
    pub fn Worker_Connection_SendEntityQueryRequest(
        connection: *mut Worker_Connection,
        entity_query: *const Worker_EntityQuery,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Sends a component update for the given entity to SpatialOS. Note that the sent component update
    /// is added as an operation to the operation list and will be returned by a subsequent call to
    /// Worker_connection_GetOpList. The update data is copied with the corresponding vtable Copy
    /// function and the copy is later freed with the vtable Free function.
    pub fn Worker_Connection_SendComponentUpdate(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        component_update: *const Worker_ComponentUpdate,
    );
}
extern "C" {
    /// Sends a component update for the given entity to SpatialOS. Note that the sent component update
    /// is added as an operation to the operation list and will be returned by a subsequent call to
    /// Worker_connection_GetOpList. The update data is copied with the corresponding vtable Copy
    /// function and the copy is later freed with the vtable Free function.
    ///
    /// This function additionally allows control over the loopback behaviour. By default, calling
    /// SendComponentUpdate will add the component update to the local operation list to be processed
    /// later, but can be disabled by passing in a Worker_Alpha_UpdateParameters object with loopback set
    /// to none.
    pub fn Worker_Alpha_Connection_SendComponentUpdate(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        component_update: *const Worker_ComponentUpdate,
        update_parameters: *const Worker_Alpha_UpdateParameters,
    );
}
extern "C" {
    /// Sends a command request targeting the given entity and component to SpatialOS. If timeout_millis
    /// is null, the default will be used. The request data is copied with the corresponding vtable Copy
    /// function and the copy is later freed with the vtable Free function.
    ///
    /// The command_id parameter has no effect other than being exposed in the
    /// Worker_CommandResponseOp so that callers can correctly handle command failures.
    ///
    /// The command parameters argument must not be NULL.
    pub fn Worker_Connection_SendCommandRequest(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        request: *const Worker_CommandRequest,
        command_id: u32,
        timeout_millis: *const u32,
        command_parameters: *const Worker_CommandParameters,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Sends a command response for the given request ID to SpatialOS. The response data is copied with
    /// the corresponding vtable Copy function and the copy is later freed with the vtable Free function.
    pub fn Worker_Connection_SendCommandResponse(
        connection: *mut Worker_Connection,
        request_id: Worker_RequestId,
        response: *const Worker_CommandResponse,
    );
}
extern "C" {
    /// Sends an explicit failure for the given command request ID to SpatialOS.
    pub fn Worker_Connection_SendCommandFailure(
        connection: *mut Worker_Connection,
        request_id: Worker_RequestId,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// Sends a diff-based component interest update for the given entity to SpatialOS. By default, the
    /// worker receives data for all entities according to the default component interest specified in
    /// its bridge settings. This function allows interest override by (entity ID, component ID) pair to
    /// force the data to either always be sent or never be sent. Note that this does not apply if the
    /// worker is _authoritative_ over a particular (entity ID, component ID) pair, in which case the
    /// data is always sent.
    pub fn Worker_Connection_SendComponentInterest(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        interest_override: *const Worker_InterestOverride,
        interest_override_count: u32,
    );
}
extern "C" {
    /// Sends an acknowledgement of the receipt of an AuthorityLossImminent authority change for a
    /// component. Sending the acknowledgement signifies that this worker is ready to lose authority
    /// over the component.
    pub fn Worker_Connection_SendAuthorityLossImminentAcknowledgement(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        component_id: Worker_ComponentId,
    );
}
extern "C" {
    /// Enables or disables protocol logging. Logging uses the parameters specified when the connection
    /// was created. Enabling it when already enabled, or disabling it when already disabled, do nothing.
    ///
    /// Note that logs from any previous protocol logging sessions will be overwritten.
    pub fn Worker_Connection_SetProtocolLoggingEnabled(
        connection: *mut Worker_Connection,
        enabled: u8,
    );
}
extern "C" {
    /// Returns true if the connection has been successfully created and communication is ongoing.
    /// DEPRECATED: Equivalent to Worker_Connection_GetConnectionStatusCode(connection) ==
    ///             WORKER_CONNECTION_STATUS_CODE_SUCCESS.
    pub fn Worker_Connection_IsConnected(connection: *const Worker_Connection) -> u8;
}
extern "C" {
    /// Returns a value from the Worker_ConnectionStatusCode enum. Returns
    /// WORKER_CONNECTION_STATUS_SUCCESS if the connection is connected and usable, otherwise a
    /// value indicating the type of error that occurred.
    pub fn Worker_Connection_GetConnectionStatusCode(connection: *const Worker_Connection) -> u8;
}
extern "C" {
    /// Returns a string containing more detailed information about the connection status. The returned
    /// pointer points to data that is owned by the SDK and will remain valid for the lifetime of the
    /// connection.
    pub fn Worker_Connection_GetConnectionStatusDetailString(
        connection: *const Worker_Connection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Retrieves the ID of the worker as assigned by the runtime. The returned pointer points to data
    /// that is owned by the SDK and will remain valid for the lifetime of the connection.
    pub fn Worker_Connection_GetWorkerId(
        connection: *const Worker_Connection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Retrieves the attributes associated with the worker at runtime. The result to data that is owned
    /// by the SDK and will remain valid for the lifetime of the connection.
    pub fn Worker_Connection_GetWorkerAttributes(
        connection: *const Worker_Connection,
    ) -> *const Worker_WorkerAttributes;
}
extern "C" {
    /// Queries the worker flag with the given name. If the worker flag does not exist, the value will
    /// be NULL.
    ///
    /// Worker flags are remotely configurable and may change during the runtime of the worker,
    /// including addition and deletion.
    pub fn Worker_Connection_GetFlag(
        connection: *const Worker_Connection,
        name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
        callback: Worker_GetFlagCallback,
    );
}
extern "C" {
    /// Retrieves the list of operations that have occurred since the last call to this function.
    ///
    /// If timeout_millis is non-zero, the function will block until there is at least one operation to
    /// return, or the timeout has been exceeded. If the timeout is exceeded, an empty list will be
    /// returned.
    ///
    /// If timeout_millis is zero the function is non-blocking.
    ///
    /// It is the caller's responsibility to destroy the returned Worker_OpList with the
    /// Worker_OpList_Destroy function.
    pub fn Worker_Connection_GetOpList(
        connection: *mut Worker_Connection,
        timeout_millis: u32,
    ) -> *mut Worker_OpList;
}
extern "C" {
    /// Frees resources for Worker_OpList returned by Worker_Connection_GetOpList.
    pub fn Worker_OpList_Destroy(op_list: *mut Worker_OpList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotParameters {
    /// Number of component vtables.
    pub component_vtable_count: u32,
    /// Component vtable for each component that the connection will deal with.
    pub component_vtables: *const Worker_ComponentVtable,
    /// Default vtable used when a component is not registered. Only used if not NULL.
    pub default_component_vtable: *const Worker_ComponentVtable,
}
extern "C" {
    /// Opens a Worker_SnapshotInputStream. The caller must manage the memory of the
    /// returned Worker_SnapshotInputStream* by calling Worker_SnapshotInputStream to
    /// write the EOF and release resources.
    ///
    /// If an error occurs, a pointer to a Worker_SnapshotInputStream is still returned.
    /// Calling Worker_SnapshotInputStream_GetError with this pointer will return
    /// an error message describing any error that occured. In the event of an error, the caller still
    /// must release the memory of the Worker_SnapshotInputStream by calling
    /// Worker_SnapshotInputStream.
    pub fn Worker_SnapshotInputStream_Create(
        filename: *const ::std::os::raw::c_char,
        params: *const Worker_SnapshotParameters,
    ) -> *mut Worker_SnapshotInputStream;
}
extern "C" {
    /// Closes the SnapshotInputStream and releases its resources.
    pub fn Worker_SnapshotInputStream_Destroy(input_stream: *mut Worker_SnapshotInputStream);
}
extern "C" {
    /// Returns zero (false) if the Worker_SnapshotInputStream has reached the EOF
    /// of the Snapshot.
    pub fn Worker_SnapshotInputStream_HasNext(input_stream: *mut Worker_SnapshotInputStream) -> u8;
}
extern "C" {
    /// Reads next Worker_Entity* entity from input_stream.
    ///
    /// Worker_SnapshotInputStream_ReadEntity manages the memory for the returned entity internally. The
    /// next call to Worker_SnapshotInputStream_ReadEntity or Worker_SnapshotInputStream_Destroy
    /// invalidates this value; use Worker_AcquireComponentData as usual to preserve component data.
    pub fn Worker_SnapshotInputStream_ReadEntity(
        input_stream: *mut Worker_SnapshotInputStream,
    ) -> *const Worker_Entity;
}
extern "C" {
    /// Must be called after any operation on Worker_SnapshotInputStream to get the error
    /// message associated with previous operation. If error is null, no error occured.
    ///
    /// Returns a read only const char* representation of the error message.
    pub fn Worker_SnapshotInputStream_GetError(
        input_stream: *mut Worker_SnapshotInputStream,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Opens Worker_SnapshotOutputStream stream. The caller must manage the memory of the
    /// returned Worker_SnapshotOutputStream* by calling
    /// Worker_SnapshotOutputStream_Destroy to write the EOF and release resources.
    ///
    /// If an error occurs, a pointer to a Worker_SnapshotOutputStream is still returned.
    /// Calling Worker_SnapshotOutputStream_GetError with this pointer will return
    /// an error message describing any error that occured. In the event of an error, the caller still
    /// must release the memory of the Worker_SnapshotOutputStream by calling
    /// Worker_SnapshotOutputStream_Destroy.
    pub fn Worker_SnapshotOutputStream_Create(
        filename: *const ::std::os::raw::c_char,
        params: *const Worker_SnapshotParameters,
    ) -> *mut Worker_SnapshotOutputStream;
}
extern "C" {
    /// Closes the snapshot output stream and releases its resources.
    pub fn Worker_SnapshotOutputStream_Destroy(output_stream: *mut Worker_SnapshotOutputStream);
}
extern "C" {
    /// Writes next entity_id, entity pair from input. Must call
    /// Worker_SnapshotOutputStream_GetError
    /// to get any error that occured during operation.
    /// Returns non-zero (true) if the write was successful.
    pub fn Worker_SnapshotOutputStream_WriteEntity(
        output_stream: *mut Worker_SnapshotOutputStream,
        entity: *const Worker_Entity,
    ) -> u8;
}
extern "C" {
    /// Must be called after any operation on Worker_SnapshotOutputStream to get the error
    /// message associated with previous operation. If error is null, no error occured.
    ///
    /// Returns a read only const char* representation of the error message.
    pub fn Worker_SnapshotOutputStream_GetError(
        output_stream: *mut Worker_SnapshotOutputStream,
    ) -> *const ::std::os::raw::c_char;
}
