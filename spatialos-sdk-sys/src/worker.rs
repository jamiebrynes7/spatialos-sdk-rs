/* automatically generated by rust-bindgen */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 29;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SCHEMA_MAP_KEY_FIELD_ID: u32 = 1;
pub const SCHEMA_MAP_VALUE_FIELD_ID: u32 = 2;
pub const WORKER_API_VERSION_MAJOR: u32 = 14;
pub const WORKER_API_VERSION_MINOR: u32 = 0;
pub const WORKER_API_VERSION_PATCH: u32 = 0;
pub const WORKER_API_VERSION: u32 = 917504;
pub const WORKER_API_VERSION_STR: &'static [u8; 5usize] = b"14.0\0";
pub const WORKER_DEFAULTS_SEND_QUEUE_CAPACITY: u32 = 4096;
pub const WORKER_DEFAULTS_RECEIVE_QUEUE_CAPACITY: u32 = 4096;
pub const WORKER_DEFAULTS_LOG_MESSAGE_QUEUE_CAPACITY: u32 = 256;
pub const WORKER_DEFAULTS_BUILT_IN_METRICS_REPORT_PERIOD_MILLIS: u32 = 5000;
pub const WORKER_DEFAULTS_CONNECTION_TIMEOUT_MILLIS: u32 = 60000;
pub const WORKER_DEFAULTS_DEFAULT_COMMAND_TIMEOUT_MILLIS: u32 = 5000;
pub const WORKER_DEFAULTS_ERASURE_CODEC_ORIGINAL_PACKET_COUNT: u32 = 10;
pub const WORKER_DEFAULTS_ERASURE_CODEC_RECOVERY_PACKET_COUNT: u32 = 2;
pub const WORKER_DEFAULTS_ERASURE_CODEC_WINDOW_SIZE: u32 = 16;
pub const WORKER_DEFAULTS_HEARTBEAT_INTERVAL_MILLIS: u32 = 10000;
pub const WORKER_DEFAULTS_HEARTBEAT_TIMEOUT_MILLIS: u32 = 60000;
pub const WORKER_DEFAULTS_FLOW_CONTROL_DOWNSTREAM_WINDOW_SIZE_BYTES: u32 = 262144;
pub const WORKER_DEFAULTS_FLOW_CONTROL_UPSTREAM_WINDOW_SIZE_BYTES: u32 = 262144;
pub const WORKER_DEFAULTS_TCP_MULTIPLEX_LEVEL: u32 = 32;
pub const WORKER_DEFAULTS_TCP_SEND_BUFFER_SIZE: u32 = 65536;
pub const WORKER_DEFAULTS_TCP_RECEIVE_BUFFER_SIZE: u32 = 65536;
pub const WORKER_DEFAULTS_TCP_NO_DELAY: u32 = 0;
pub const WORKER_DEFAULTS_RAKNET_HEARTBEAT_TIMEOUT_MILLIS: u32 = 60000;
pub const WORKER_DEFAULTS_KCP_FAST_RETRANSMISSION: u32 = 1;
pub const WORKER_DEFAULTS_KCP_EARLY_RETRANSMISSION: u32 = 1;
pub const WORKER_DEFAULTS_KCP_NON_CONCESSIONAL_FLOW_CONTROL: u32 = 1;
pub const WORKER_DEFAULTS_KCP_MULTIPLEX_LEVEL: u32 = 32;
pub const WORKER_DEFAULTS_KCP_UPDATE_INTERVAL_MILLIS: u32 = 10;
pub const WORKER_DEFAULTS_KCP_MIN_RTO_MILLIS: u32 = 10;
pub const WORKER_DEFAULTS_KCP_SEND_WINDOW_SIZE: u32 = 500;
pub const WORKER_DEFAULTS_KCP_RECV_WINDOW_SIZE: u32 = 1000;
pub const WORKER_DEFAULTS_KCP_ENABLE_ERASURE_CODEC: u32 = 0;
pub const WORKER_DEFAULTS_LOG_PREFIX: &'static [u8; 14usize] = b"protocol-log-\0";
pub const WORKER_DEFAULTS_MAX_LOG_FILES: u32 = 10;
pub const WORKER_DEFAULTS_MAX_LOG_FILE_SIZE_BYTES: u32 = 1048576;
pub const WORKER_DEFAULTS_ENABLE_DYNAMIC_COMPONENTS: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_CommandRequest {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_CommandResponse {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_ComponentData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_ComponentUpdate {
    _unused: [u8; 0],
}
pub type Schema_FieldId = u32;
pub type Schema_EntityId = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_Bundle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_Object {
    _unused: [u8; 0],
}
#[doc = " An error callback, used to signal error messages for debugging."]
pub type Schema_ErrorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        error: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = " Load a serialized schema bundle from a byte buffer. This byte buffer should contain a fully"]
    #[doc = " loaded schema bundle generated by the schema compiler using the `--bundle_out` argument."]
    #[doc = ""]
    #[doc = " Make sure to call `Schema_Bundle_GetError` after loading to check if there were any errors when"]
    #[doc = " loading."]
    pub fn Schema_Bundle_Load(buffer: *const u8, length: u32) -> *mut Schema_Bundle;
}
extern "C" {
    #[doc = " Returns a null-terminated string containing one or more error messages (separated by '\\n') if any"]
    #[doc = " errors were encountered when loading the schema bundle. Note that the string buffer returned is"]
    #[doc = " stored inside the schema bundle, and therefore will be freed when the bundle is destroyed. Will"]
    #[doc = " return NULL if there were no errors."]
    pub fn Schema_Bundle_GetError(bundle: *const Schema_Bundle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Free the resources associated with a schema bundle."]
    pub fn Schema_Bundle_Destroy(bundle: *mut Schema_Bundle);
}
extern "C" {
    #[doc = " Allocate a command request schema type instance."]
    pub fn Schema_CreateCommandRequest() -> *mut Schema_CommandRequest;
}
extern "C" {
    #[doc = " Performs a deep copy of the source command request and returns the new copy."]
    pub fn Schema_CopyCommandRequest(
        source: *const Schema_CommandRequest,
    ) -> *mut Schema_CommandRequest;
}
extern "C" {
    #[doc = " Free the resources associated with a command request schema type instance."]
    pub fn Schema_DestroyCommandRequest(request: *mut Schema_CommandRequest);
}
extern "C" {
    #[doc = " Get the command request as a Schema_Object."]
    pub fn Schema_GetCommandRequestObject(
        request: *mut Schema_CommandRequest,
    ) -> *mut Schema_Object;
}
extern "C" {
    #[doc = " Allocate a command response schema type instance."]
    pub fn Schema_CreateCommandResponse() -> *mut Schema_CommandResponse;
}
extern "C" {
    #[doc = " Performs a deep copy of the source command response and returns the new copy."]
    pub fn Schema_CopyCommandResponse(
        source: *const Schema_CommandResponse,
    ) -> *mut Schema_CommandResponse;
}
extern "C" {
    #[doc = " Free the resources associated with a command response schema type instance."]
    pub fn Schema_DestroyCommandResponse(response: *mut Schema_CommandResponse);
}
extern "C" {
    #[doc = " Get the command response as a Schema_Object."]
    pub fn Schema_GetCommandResponseObject(
        response: *mut Schema_CommandResponse,
    ) -> *mut Schema_Object;
}
extern "C" {
    #[doc = " Allocate a component data snapshot schema type instance."]
    pub fn Schema_CreateComponentData() -> *mut Schema_ComponentData;
}
extern "C" {
    #[doc = " Performs a deep copy of the source component data and returns the new copy."]
    pub fn Schema_CopyComponentData(
        source: *const Schema_ComponentData,
    ) -> *mut Schema_ComponentData;
}
extern "C" {
    #[doc = " Free the resources associated with a component data snapshot schema type instance."]
    pub fn Schema_DestroyComponentData(data: *mut Schema_ComponentData);
}
extern "C" {
    #[doc = " Get the command data snapshot as a Schema_Object."]
    pub fn Schema_GetComponentDataFields(data: *mut Schema_ComponentData) -> *mut Schema_Object;
}
extern "C" {
    #[doc = " Allocate a component update schema type instance."]
    pub fn Schema_CreateComponentUpdate() -> *mut Schema_ComponentUpdate;
}
extern "C" {
    #[doc = " Performs a deep copy of the source component update and returns the new copy."]
    pub fn Schema_CopyComponentUpdate(
        source: *const Schema_ComponentUpdate,
    ) -> *mut Schema_ComponentUpdate;
}
extern "C" {
    #[doc = " Free the resources associated with a component update schema type instance."]
    pub fn Schema_DestroyComponentUpdate(update: *mut Schema_ComponentUpdate);
}
extern "C" {
    #[doc = " Get an object representing the non-event fields in a component update. This object should be used"]
    #[doc = " as if it had one field for each field in the component, whose type corresponds to the type of the"]
    #[doc = " field as defined in schema. Note that when an option, list or map field in a component is set to"]
    #[doc = " the empty value, it will not / should not appear here. Instead, use"]
    #[doc = " Schema_IndexComponentUpdateClearedField and related functions."]
    pub fn Schema_GetComponentUpdateFields(
        update: *mut Schema_ComponentUpdate,
    ) -> *mut Schema_Object;
}
extern "C" {
    #[doc = " Get an object representing the event fields in a component update. This object should be used"]
    #[doc = " as if it had one field for each event in the component. Each field behaves like a list (may have"]
    #[doc = " multiple instances of the same event), and the field ID of an event is its 1-based position in"]
    #[doc = " the order the events appear in the component in the schema."]
    pub fn Schema_GetComponentUpdateEvents(
        update: *mut Schema_ComponentUpdate,
    ) -> *mut Schema_Object;
}
extern "C" {
    #[doc = " Clears the list of fields that this update sets to the empty value (for option, list and map"]
    #[doc = " fields in a component)."]
    pub fn Schema_ClearComponentUpdateClearedFields(update: *mut Schema_ComponentUpdate);
}
extern "C" {
    #[doc = " Checks whether this updates sets an option, list of map field in a component to the empty value."]
    pub fn Schema_IsComponentUpdateFieldCleared(
        update: *mut Schema_ComponentUpdate,
        field_id: Schema_FieldId,
    ) -> u8;
}
extern "C" {
    #[doc = " Specifies that this update sets an option, list or map field in a component to the empty"]
    #[doc = " value."]
    pub fn Schema_AddComponentUpdateClearedField(
        update: *mut Schema_ComponentUpdate,
        field_id: Schema_FieldId,
    );
}
extern "C" {
    #[doc = " Returns the number of option, list and map fields in a component that this update sets to the"]
    #[doc = " empty value."]
    pub fn Schema_GetComponentUpdateClearedFieldCount(update: *const Schema_ComponentUpdate)
        -> u32;
}
extern "C" {
    #[doc = " Returns the field ID of an option, list or map field which is set to the empty value by this"]
    #[doc = " update."]
    pub fn Schema_IndexComponentUpdateClearedField(
        update: *const Schema_ComponentUpdate,
        index: u32,
    ) -> Schema_FieldId;
}
extern "C" {
    #[doc = " Returns all field IDs of option, list, or map fields which are set to the empty value by this"]
    #[doc = " component. The output_array should have space for"]
    #[doc = " Schema_GetComponentUpdateClearedFieldCount(update) field IDs."]
    pub fn Schema_GetComponentUpdateClearedFieldList(
        update: *const Schema_ComponentUpdate,
        output_array: *mut Schema_FieldId,
    );
}
extern "C" {
    #[doc = " Merges a component update 'update' into an at-rest component data object 'target_data'. This is"]
    #[doc = " semantically equivalent to a component update being \"applied\" to the at-rest component data."]
    #[doc = ""]
    #[doc = " This function will mutate the component data object by appending the bytes representation of the"]
    #[doc = " update to the end of the component data. This is efficient because if the component update is"]
    #[doc = " small, it wouldn't need to reshuffle any fields under the hood, but will have unbounded memory"]
    #[doc = " growth (proportional to the serialized component update after each function call)."]
    #[doc = ""]
    #[doc = " To avoid mutating the data and having unbounded memory growth, use this function in combination"]
    #[doc = " with Schema_CopyComponentData to copy the component data first. Note that calling"]
    #[doc = " Schema_CopyComponentData on a component data will only require storage for the serialized size of"]
    #[doc = " the component data in the returned object, hence why memory growth is no longer unbounded when"]
    #[doc = " this is used."]
    #[doc = ""]
    #[doc = " Returns 1 if success, 0 if there was a failure. Call"]
    #[doc = " `Schema_GetError(Schema_GetComponentDataFields(target_data))` to get the error message."]
    pub fn Schema_ApplyComponentUpdateToData(
        update: *const Schema_ComponentUpdate,
        target_data: *mut Schema_ComponentData,
    ) -> u8;
}
extern "C" {
    #[doc = " Merges a component update 'update' into another component update object 'target_update'. This is"]
    #[doc = " semantically equivalent to combining two component updates into a single component update such"]
    #[doc = " that, when applied to some at-rest component data, it will be semantically equivalent to applying"]
    #[doc = " 'target_update' followed by 'update'. 'target_update' will be mutated to contain the resulting"]
    #[doc = " combined update."]
    #[doc = ""]
    #[doc = " Unlike Schema_ApplyComponentUpdateToData, this function will not have unbounded memory growth. To"]
    #[doc = " avoid mutating 'target_update', use this function in combination with Schema_CopyComponentUpdate"]
    #[doc = " to create a copy which will contain the resulting merged update."]
    #[doc = ""]
    #[doc = " 'update' will be empty after this operation, so ensure to call"]
    #[doc = " Schema_DestroyComponentUpdate(update) to avoid leaking memory."]
    #[doc = ""]
    #[doc = " Returns 1 if success, 0 if there was a failure. Call"]
    #[doc = " `Schema_GetError(Schema_GetComponentUpdateFields(target_update))` to get the error message."]
    pub fn Schema_MergeComponentUpdateIntoUpdate(
        update: *mut Schema_ComponentUpdate,
        target_update: *mut Schema_ComponentUpdate,
    ) -> u8;
}
extern "C" {
    #[doc = " Takes an at-rest component data object 'data', and converts it into a component update with all"]
    #[doc = " fields set. The resulting component update has the property that if applied to a component data"]
    #[doc = " object, it is guaranteed to result in the original at-rest component data object 'data'. Any"]
    #[doc = " fields contained in 'data' which are not present in the component definition will be dropped."]
    #[doc = ""]
    #[doc = " This operation requires a component definition to be provided at runtime in a schema bundle. See"]
    #[doc = " `Schema_Bundle_Load` for more information."]
    #[doc = ""]
    #[doc = " If successful, 'data' will become empty after this operation. Otherwise, 'data' will be left in a"]
    #[doc = " valid but unspecified state. After calling this function, we recommend immediately calling"]
    #[doc = " Schema_DestroyComponentData(data) to avoid leaking memory."]
    #[doc = ""]
    #[doc = " A new component update object will be returned to the caller on success, otherwise NULL will be"]
    #[doc = " returned on failure."]
    #[doc = ""]
    #[doc = " An error callback can be optionally provided to get more information as to why the operation"]
    #[doc = " failed. 'callback_user_data' is an arbitrary value that will be passed to the callback. If"]
    #[doc = " unused, or no error callback is specified, this parameter can be set to NULL."]
    pub fn Schema_ConvertComponentDataIntoUpdate(
        bundle: *const Schema_Bundle,
        component_id: Schema_FieldId,
        data: *mut Schema_ComponentData,
        callback_user_data: *mut ::std::os::raw::c_void,
        error_callback: Schema_ErrorCallback,
    ) -> *mut Schema_ComponentUpdate;
}
extern "C" {
    #[doc = " Completely clears all fields in the given object."]
    pub fn Schema_Clear(object: *mut Schema_Object);
}
extern "C" {
    #[doc = " Completely clears the given field ID in the given object."]
    pub fn Schema_ClearField(object: *mut Schema_Object, field_id: Schema_FieldId);
}
extern "C" {
    #[doc = " Copies all fields from `src` to `dst`. The copy is shallow; changes made to object fields in the"]
    #[doc = " source will also be reflected in the copied fields."]
    #[doc = ""]
    #[doc = " If `src == dst`, or if the objects are not associated with the same root schema type instance, no"]
    #[doc = " operation is performed."]
    pub fn Schema_ShallowCopy(src: *const Schema_Object, dst: *mut Schema_Object);
}
extern "C" {
    #[doc = " Copies over a field from `src` to `dst`. If multiple fields with the given field_id exist all"]
    #[doc = " are copied. The copy is shallow; changes made to object fields in the source will also be"]
    #[doc = " reflected in the copied fields."]
    #[doc = ""]
    #[doc = " If `src == dst`, or if the objects are not associated with the same root schema type instance, no"]
    #[doc = " operation is performed."]
    pub fn Schema_ShallowCopyField(
        src: *const Schema_Object,
        dst: *mut Schema_Object,
        field_id: Schema_FieldId,
    );
}
extern "C" {
    #[doc = " Allocates an orphaned Schema_Object in memory owned by the given Schema_Object instance. The"]
    #[doc = " returned object is owned by the associated schema type instance, but is not reachable from any"]
    #[doc = " other object. The memory is freed by a call to Schema_Destroy."]
    pub fn Schema_AllocateObject(object: *const Schema_Object) -> *mut Schema_Object;
}
extern "C" {
    #[doc = " Allocates a buffer of the specified length in bytes from memory owned by the given Schema_Object"]
    #[doc = " instance. The memory is freed by a call to Schema_Destroy."]
    #[doc = ""]
    #[doc = " Note: this is useful for allocating memory that must live as long as the root schema type"]
    #[doc = " instance, for example to pass to Schema_MergeFromBuffer."]
    pub fn Schema_AllocateBuffer(object: *mut Schema_Object, length: u32) -> *mut u8;
}
extern "C" {
    #[doc = " Merges the given buffer into the given object, appending all fields. This function"]
    #[doc = " can fail; if the return value is zero, call Schema_GetError to obtain an error string."]
    #[doc = ""]
    #[doc = " Note: the provided buffer is not copied, and must live as long as the root schema type instance."]
    pub fn Schema_MergeFromBuffer(object: *mut Schema_Object, buffer: *const u8, length: u32)
        -> u8;
}
extern "C" {
    #[doc = " Computes the serialized length of the given Schema_Object."]
    pub fn Schema_GetWriteBufferLength(object: *const Schema_Object) -> u32;
}
extern "C" {
    #[doc = " Serializes the given object into the provided buffer, which _must_ have space at"]
    #[doc = " least equal to the length returned by Schema_WriteBufferLength. This function can"]
    #[doc = " fail; if the return value is zero, call Schema_GetError to obtain an error string."]
    #[doc = ""]
    #[doc = " `length` must equal the value returned by `Schema_GetWriteBufferLength`. Otherwise, the behavior"]
    #[doc = " is undefined."]
    pub fn Schema_SerializeToBuffer(
        object: *const Schema_Object,
        buffer: *mut u8,
        length: u32,
    ) -> u8;
}
extern "C" {
    #[doc = " Obtains the most recent error encountered by any object associated with the given object. The"]
    #[doc = " buffer is owned by the schema object that manages the memory of `object`, and may get replaced"]
    #[doc = " after calling another Schema function. Returns `NULL` if no error has occurred within the given"]
    #[doc = " object."]
    pub fn Schema_GetError(object: *const Schema_Object) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the number of unique field IDs used in the Schema_Object."]
    pub fn Schema_GetUniqueFieldIdCount(object: *const Schema_Object) -> u32;
}
extern "C" {
    #[doc = " Returns the sorted list of unique field IDs used in the Schema_Object. The buffer parameter"]
    #[doc = " must have space remaining for as many field IDs as indicated by Schema_GetUniqueFieldIdCount."]
    pub fn Schema_GetUniqueFieldIds(object: *const Schema_Object, buffer: *mut u32);
}
extern "C" {
    pub fn Schema_AddFloat(object: *mut Schema_Object, field_id: Schema_FieldId, value: f32);
}
extern "C" {
    pub fn Schema_AddDouble(object: *mut Schema_Object, field_id: Schema_FieldId, value: f64);
}
extern "C" {
    pub fn Schema_AddBool(object: *mut Schema_Object, field_id: Schema_FieldId, value: u8);
}
extern "C" {
    pub fn Schema_AddInt32(object: *mut Schema_Object, field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddInt64(object: *mut Schema_Object, field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddUint32(object: *mut Schema_Object, field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddUint64(object: *mut Schema_Object, field_id: Schema_FieldId, value: u64);
}
extern "C" {
    pub fn Schema_AddSint32(object: *mut Schema_Object, field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddSint64(object: *mut Schema_Object, field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddFixed32(object: *mut Schema_Object, field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddFixed64(object: *mut Schema_Object, field_id: Schema_FieldId, value: u64);
}
extern "C" {
    pub fn Schema_AddSfixed32(object: *mut Schema_Object, field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddSfixed64(object: *mut Schema_Object, field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddEntityId(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        value: Schema_EntityId,
    );
}
extern "C" {
    pub fn Schema_AddEnum(object: *mut Schema_Object, field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddBytes(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        buffer: *const u8,
        length: u32,
    );
}
extern "C" {
    pub fn Schema_AddObject(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
    ) -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_AddFloatList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const f32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddDoubleList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const f64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddBoolList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u8,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddInt32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddInt64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddUint32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddUint64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSint32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSint64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddFixed32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddFixed64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSfixed32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSfixed64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddEntityIdList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const Schema_EntityId,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddEnumList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_GetFloatCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetDoubleCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBoolCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetInt32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetInt64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSint32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSint64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSfixed32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSfixed64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetEntityIdCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetEnumCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytesCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetObjectCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFloat(object: *const Schema_Object, field_id: Schema_FieldId) -> f32;
}
extern "C" {
    pub fn Schema_GetDouble(object: *const Schema_Object, field_id: Schema_FieldId) -> f64;
}
extern "C" {
    pub fn Schema_GetBool(object: *const Schema_Object, field_id: Schema_FieldId) -> u8;
}
extern "C" {
    pub fn Schema_GetInt32(object: *const Schema_Object, field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetInt64(object: *const Schema_Object, field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetUint32(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint64(object: *const Schema_Object, field_id: Schema_FieldId) -> u64;
}
extern "C" {
    pub fn Schema_GetSint32(object: *const Schema_Object, field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetSint64(object: *const Schema_Object, field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetFixed32(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed64(object: *const Schema_Object, field_id: Schema_FieldId) -> u64;
}
extern "C" {
    pub fn Schema_GetSfixed32(object: *const Schema_Object, field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetSfixed64(object: *const Schema_Object, field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetEntityId(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
    ) -> Schema_EntityId;
}
extern "C" {
    pub fn Schema_GetEnum(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytesLength(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytes(object: *const Schema_Object, field_id: Schema_FieldId) -> *const u8;
}
extern "C" {
    pub fn Schema_GetObject(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
    ) -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_IndexFloat(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> f32;
}
extern "C" {
    pub fn Schema_IndexDouble(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> f64;
}
extern "C" {
    pub fn Schema_IndexBool(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Schema_IndexInt32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i32;
}
extern "C" {
    pub fn Schema_IndexInt64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i64;
}
extern "C" {
    pub fn Schema_IndexUint32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexUint64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u64;
}
extern "C" {
    pub fn Schema_IndexSint32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i32;
}
extern "C" {
    pub fn Schema_IndexSint64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i64;
}
extern "C" {
    pub fn Schema_IndexFixed32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexFixed64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u64;
}
extern "C" {
    pub fn Schema_IndexSfixed32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i32;
}
extern "C" {
    pub fn Schema_IndexSfixed64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i64;
}
extern "C" {
    pub fn Schema_IndexEntityId(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> Schema_EntityId;
}
extern "C" {
    pub fn Schema_IndexEnum(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexBytesLength(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexBytes(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> *const u8;
}
extern "C" {
    pub fn Schema_IndexObject(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_GetFloatList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut f32,
    );
}
extern "C" {
    pub fn Schema_GetDoubleList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut f64,
    );
}
extern "C" {
    pub fn Schema_GetBoolList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u8,
    );
}
extern "C" {
    pub fn Schema_GetInt32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i32,
    );
}
extern "C" {
    pub fn Schema_GetInt64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i64,
    );
}
extern "C" {
    pub fn Schema_GetUint32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u32,
    );
}
extern "C" {
    pub fn Schema_GetUint64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u64,
    );
}
extern "C" {
    pub fn Schema_GetSint32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i32,
    );
}
extern "C" {
    pub fn Schema_GetSint64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i64,
    );
}
extern "C" {
    pub fn Schema_GetFixed32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u32,
    );
}
extern "C" {
    pub fn Schema_GetFixed64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u64,
    );
}
extern "C" {
    pub fn Schema_GetSfixed32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i32,
    );
}
extern "C" {
    pub fn Schema_GetSfixed64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i64,
    );
}
extern "C" {
    pub fn Schema_GetEntityIdList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut Schema_EntityId,
    );
}
extern "C" {
    pub fn Schema_GetEnumList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u32,
    );
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type Worker_EntityId = i64;
pub type Worker_ComponentId = u32;
pub type Worker_CommandIndex = u32;
pub type Worker_RequestId = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ConnectionFuture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DeploymentListFuture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_PlayerIdentityTokenResponseFuture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_LoginTokensResponseFuture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Locator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotInputStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotOutputStream {
    _unused: [u8; 0],
}
pub const Worker_LogLevel_WORKER_LOG_LEVEL_DEBUG: Worker_LogLevel = 1;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_INFO: Worker_LogLevel = 2;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_WARN: Worker_LogLevel = 3;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_ERROR: Worker_LogLevel = 4;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_FATAL: Worker_LogLevel = 5;
#[doc = " Enum defining the severities of log messages that can be sent to SpatialOS and received from the"]
#[doc = " SDK."]
pub type Worker_LogLevel = u32;
#[doc = " The request was successfully executed and returned a response."]
pub const Worker_StatusCode_WORKER_STATUS_CODE_SUCCESS: Worker_StatusCode = 1;
#[doc = " The request timed out before a response was received. It can be retried, but carefully - this"]
#[doc = " usually means the deployment is overloaded, so some sort of backoff should be used to avoid"]
#[doc = " making the problem worse. This can also be caused by the target worker's handling code failing"]
#[doc = " to respond to the command at all, perhaps due to a bug in its implementation."]
pub const Worker_StatusCode_WORKER_STATUS_CODE_TIMEOUT: Worker_StatusCode = 2;
#[doc = " The target entity did not exist, or did not have the target component. This probably means"]
#[doc = " the entity either hasn't been created yet or has already been deleted. It might make sense to"]
#[doc = " retry the request if there is reason to believe the entity hasn't yet been created but will be"]
#[doc = " soon."]
pub const Worker_StatusCode_WORKER_STATUS_CODE_NOT_FOUND: Worker_StatusCode = 3;
#[doc = " The request could not be executed by a worker, either because the worker lost authority over"]
#[doc = " the entity while handling the request, the entity was deleted while handling the request, or no"]
#[doc = " worker was authoritative over the entity at all. Assuming the deployment isn't irrecoverably"]
#[doc = " broken (e.g. due to misconfigured loadbalancing or crash-looping workers) this is a transient"]
#[doc = " failure and can be retried immediately."]
pub const Worker_StatusCode_WORKER_STATUS_CODE_AUTHORITY_LOST: Worker_StatusCode = 4;
#[doc = " The worker did not have the required permissions to make the request. Permissions do not change"]
#[doc = " at runtime, so it doesn't make sense to retry the request."]
pub const Worker_StatusCode_WORKER_STATUS_CODE_PERMISSION_DENIED: Worker_StatusCode = 5;
#[doc = " The command was delivered successfully, but the handler rejected it. Either the command was"]
#[doc = " delivered to a worker that explicitly rejected it by calling Connection::SendCommandFailure, or"]
#[doc = " the request data was rejected as invalid by SpatialOS itself. In the latter case, in"]
#[doc = " particular, Worker_Connection_SendCreateEntityRequest will return kApplicationError if an"]
#[doc = " entity ID reservation has expired, and Worker_Connection_SendEntityQueryResult will return"]
#[doc = " kApplicationError if the result set is incomplete."]
pub const Worker_StatusCode_WORKER_STATUS_CODE_APPLICATION_ERROR: Worker_StatusCode = 6;
#[doc = " Some other error occurred. This likely indicates a bug in SpatialOS and should be reported."]
pub const Worker_StatusCode_WORKER_STATUS_CODE_INTERNAL_ERROR: Worker_StatusCode = 7;
#[doc = " Enum defining possible command status codes."]
pub type Worker_StatusCode = u32;
#[doc = " The remote call was successful, or we are successfully connected."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_SUCCESS:
    Worker_ConnectionStatusCode = 1;
#[doc = " Protocol violation, or some part of the system otherwise behaved in an unexpected way. Not"]
#[doc = " expected to occur in normal operation."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_INTERNAL_ERROR:
    Worker_ConnectionStatusCode = 2;
#[doc = " An argument provided by the caller was determined to be invalid. This is a local failure; no"]
#[doc = " actual attempt was made to contact the host. Not retryable."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_INVALID_ARGUMENT:
    Worker_ConnectionStatusCode = 3;
#[doc = " Failed due to a networking issue or otherwise unreachable host."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_NETWORK_ERROR:
    Worker_ConnectionStatusCode = 4;
#[doc = " A timeout provided by the caller or enforced by the system was exceeded. Can be retried."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_TIMEOUT:
    Worker_ConnectionStatusCode = 5;
#[doc = " Attempt was cancelled by the caller. Currently shouldn't happen; reserved for future use."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_CANCELLED:
    Worker_ConnectionStatusCode = 6;
#[doc = " Made contact with the host, but the request was explicitly rejected. Unlikely to be retryable."]
#[doc = " Possible causes include: the request was made to the wrong host; the host considered the"]
#[doc = " request invalid for some othe reason."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_REJECTED:
    Worker_ConnectionStatusCode = 7;
#[doc = " The player identity token provided by the caller has expired. Generate a new one and retry."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_PLAYER_IDENTITY_TOKEN_EXPIRED : Worker_ConnectionStatusCode = 8 ;
#[doc = " The login token provided by the caller has expired. Generate a new one and retry."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_LOGIN_TOKEN_EXPIRED:
    Worker_ConnectionStatusCode = 9;
#[doc = " Failed because the deployment associated with the provided login token was at capacity."]
#[doc = " Retryable."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_CAPACITY_EXCEEDED:
    Worker_ConnectionStatusCode = 10;
#[doc = " Failed due to rate-limiting of new connections to the deployment associated with the provided"]
#[doc = " login token. Retryable."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_RATE_EXCEEDED:
    Worker_ConnectionStatusCode = 11;
#[doc = " After a successful connection attempt, the server later explicitly terminated the connection."]
#[doc = " Possible causes include: the deployment was stopped; the worker was killed due to"]
#[doc = " unresponsiveness."]
pub const Worker_ConnectionStatusCode_WORKER_CONNECTION_STATUS_CODE_SERVER_SHUTDOWN:
    Worker_ConnectionStatusCode = 12;
#[doc = " Possible status codes for a remote call, connection attempt, or connection migration attempt."]
pub type Worker_ConnectionStatusCode = u32;
pub const Worker_Result_WORKER_RESULT_FAILURE: Worker_Result = -1;
pub const Worker_Result_WORKER_RESULT_SUCCESS: Worker_Result = 0;
#[doc = " Enum defining possible result codes for API methods."]
#[doc = " WORKER_RESULT_FAILURE is consistent with invalid Worker_RequestId -1."]
pub type Worker_Result = i32;
pub const Worker_Authority_WORKER_AUTHORITY_NOT_AUTHORITATIVE: Worker_Authority = 0;
pub const Worker_Authority_WORKER_AUTHORITY_AUTHORITATIVE: Worker_Authority = 1;
pub const Worker_Authority_WORKER_AUTHORITY_AUTHORITY_LOSS_IMMINENT: Worker_Authority = 2;
#[doc = " Enum defining the possible authority states for an entity component."]
pub type Worker_Authority = u32;
pub const Worker_ComponentUpdateLoopback_WORKER_COMPONENT_UPDATE_LOOPBACK_NONE:
    Worker_ComponentUpdateLoopback = 0;
pub const Worker_ComponentUpdateLoopback_WORKER_COMPONENT_UPDATE_LOOPBACK_SHORT_CIRCUITED:
    Worker_ComponentUpdateLoopback = 1;
#[doc = " Enum defining the possible modes of loopback when updating a component."]
pub type Worker_ComponentUpdateLoopback = u32;
#[doc = " Parameters for sending a log message to SpatialOS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LogMessage {
    #[doc = " The severity of the log message; defined in the Worker_LogLevel enumeration."]
    pub level: u8,
    #[doc = " The name of the logger."]
    pub logger_name: *const ::std::os::raw::c_char,
    #[doc = " The full log message."]
    pub message: *const ::std::os::raw::c_char,
    #[doc = " The ID of the entity this message relates to, or NULL for none."]
    pub entity_id: *const Worker_EntityId,
}
impl Default for Worker_LogMessage {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Parameters for a gauge metric."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_GaugeMetric {
    pub key: *const ::std::os::raw::c_char,
    pub value: f64,
}
impl Default for Worker_GaugeMetric {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_HistogramMetricBucket {
    pub upper_bound: f64,
    pub samples: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_HistogramMetric {
    pub key: *const ::std::os::raw::c_char,
    pub sum: f64,
    pub bucket_count: u32,
    pub buckets: *const Worker_HistogramMetricBucket,
}
impl Default for Worker_HistogramMetric {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Parameters for sending metrics to SpatialOS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Metrics {
    #[doc = " The load value of this worker. If NULL, do not report load."]
    pub load: *const f64,
    #[doc = " The number of gauge metrics."]
    pub gauge_metric_count: u32,
    #[doc = " Array of gauge metrics."]
    pub gauge_metrics: *const Worker_GaugeMetric,
    #[doc = " The number of histogram metrics."]
    pub histogram_metric_count: u32,
    #[doc = " Array of histogram metrics."]
    pub histogram_metrics: *const Worker_HistogramMetric,
}
impl Default for Worker_Metrics {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Worker_CommandRequestHandle = ::std::os::raw::c_void;
pub type Worker_CommandResponseHandle = ::std::os::raw::c_void;
pub type Worker_ComponentDataHandle = ::std::os::raw::c_void;
pub type Worker_ComponentUpdateHandle = ::std::os::raw::c_void;
pub type Worker_CommandRequestFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        command_index: Worker_CommandIndex,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandRequestHandle,
    ),
>;
pub type Worker_CommandResponseFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        command_index: Worker_CommandIndex,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandResponseHandle,
    ),
>;
pub type Worker_ComponentDataFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentDataHandle,
    ),
>;
pub type Worker_ComponentUpdateFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentUpdateHandle,
    ),
>;
pub type Worker_CommandRequestCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        command_index: Worker_CommandIndex,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandRequestHandle,
    ) -> *mut Worker_CommandRequestHandle,
>;
pub type Worker_CommandResponseCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        command_index: Worker_CommandIndex,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandResponseHandle,
    ) -> *mut Worker_CommandResponseHandle,
>;
pub type Worker_ComponentDataCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentDataHandle,
    ) -> *mut Worker_ComponentDataHandle,
>;
pub type Worker_ComponentUpdateCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentUpdateHandle,
    ) -> *mut Worker_ComponentUpdateHandle,
>;
pub type Worker_CommandRequestDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        command_index: Worker_CommandIndex,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_CommandRequest,
        handle_out: *mut *mut Worker_CommandRequestHandle,
    ) -> u8,
>;
pub type Worker_CommandResponseDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        command_index: Worker_CommandIndex,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_CommandResponse,
        handle_out: *mut *mut Worker_CommandResponseHandle,
    ) -> u8,
>;
pub type Worker_ComponentDataDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_ComponentData,
        handle_out: *mut *mut Worker_ComponentDataHandle,
    ) -> u8,
>;
pub type Worker_ComponentUpdateDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_ComponentUpdate,
        handle_out: *mut *mut Worker_ComponentUpdateHandle,
    ) -> u8,
>;
pub type Worker_CommandRequestSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        command_index: Worker_CommandIndex,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandRequestHandle,
        target_out: *mut *mut Schema_CommandRequest,
    ),
>;
pub type Worker_CommandResponseSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        command_index: Worker_CommandIndex,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandResponseHandle,
        target_out: *mut *mut Schema_CommandResponse,
    ),
>;
pub type Worker_ComponentDataSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentDataHandle,
        target_out: *mut *mut Schema_ComponentData,
    ),
>;
pub type Worker_ComponentUpdateSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentUpdateHandle,
        target_out: *mut *mut Schema_ComponentUpdate,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentVtable {
    #[doc = " Component ID that this vtable is for. If this is the default vtable, this field is ignored."]
    pub component_id: Worker_ComponentId,
    #[doc = " User data which will be passed directly to the callbacks supplied below."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " The function pointers below are only necessary in order to use the user_handle fields present"]
    #[doc = " in each of the Worker_CommandRequest, Worker_CommandResponse, Worker_ComponentData and"]
    #[doc = " Worker_ComponentUpdate types, for the given component ID (or for all components without an"]
    #[doc = " explicit vtable, if this is the default vtable), in order to offload serialization and"]
    #[doc = " deserialization work to internal SDK threads."]
    #[doc = ""]
    #[doc = " For simplest usage of the SDK, all function pointers can be set to NULL, and only the"]
    #[doc = " schema_type field should be used in each type."]
    #[doc = ""]
    #[doc = " In order to support usage of the user_handle field on instances of the corresponding type when"]
    #[doc = " used as input data to the SDK, X_serialize() must be provided."]
    #[doc = ""]
    #[doc = " In order to support usage of the user_handle field on instances of the corresponding type when"]
    #[doc = " received as output data to the SDK, X_deserialize() must be provided."]
    #[doc = ""]
    #[doc = " X_free() should free resources associated with the result of calling X_deserialize() or"]
    #[doc = " X_copy() (if provided)."]
    #[doc = ""]
    #[doc = " This decision can be made on a per-component, per-handle-type, and per-direction (input or"]
    #[doc = " output) basis. In the case of providing data to the SDK, the asynchronous serialization flow"]
    #[doc = " can be disabled even on a per-call basis by providing a non-NULL schema_type pointer instead of"]
    #[doc = " a user_handle pointer. The concrete types pointed to by the user_handle fields may differ"]
    #[doc = " between components or between handle types."]
    #[doc = ""]
    #[doc = " All of the functions below, if provided, will be called from arbitrary internal SDK threads,"]
    #[doc = " and therefore must be thread-safe. A single user_handle pointer will not be passed to multiple"]
    #[doc = " callbacks concurrently, but a user_handle may be copied twice and the _results_ of those copies"]
    #[doc = " may be used concurrently."]
    #[doc = ""]
    #[doc = " For a concrete example, consider calling Worker_Connection_SendComponentUpdate() with"]
    #[doc = " short-circuiting enabled. The SDK will call component_update_copy() twice on the provided"]
    #[doc = " user_handle. One copy will be used for the outgoing flow, and will be serialized with"]
    #[doc = " component_update_serialize() and subsequently freed with component_update_free(). Concurrently,"]
    #[doc = " the other copy will be passed back to the user as part of a Worker_OpList and freed with"]
    #[doc = " component_update_free() when the OpList is deallocated (or, if its lifetime is extended with"]
    #[doc = " Worker_AcquireComponentUpdate(), when the last reference is released by the user with"]
    #[doc = " Worker_ReleaseComponentUpdate())."]
    #[doc = ""]
    #[doc = " In general, the two most obvious strategies are:"]
    #[doc = " 1) reference-counting. Have X_copy() (atomically) increase a reference count and return the"]
    #[doc = "    same pointer it was given, have X_free() (atomically) decrease the reference count and"]
    #[doc = "    deallocate if zero. X_deserialize() should allocate a new object with reference count of 1,"]
    #[doc = "    set the reference count of any new handle passed into the SDK to 1 initially and call"]
    #[doc = "    X_free() manually afterwards. In this case, data owned by the user_handle should never be"]
    #[doc = "    mutated after its first use. (This is the approach used internally for the schema_type.)"]
    #[doc = " 2) deep-copying. Have X_copy() allocate an entirely new deep copy of the object, and X_free()"]
    #[doc = "    deallocate directly. In this case, user_handles can be mutated freely."]
    pub command_request_free: Worker_CommandRequestFree,
    pub command_request_copy: Worker_CommandRequestCopy,
    pub command_request_deserialize: Worker_CommandRequestDeserialize,
    pub command_request_serialize: Worker_CommandRequestSerialize,
    pub command_response_free: Worker_CommandResponseFree,
    pub command_response_copy: Worker_CommandResponseCopy,
    pub command_response_deserialize: Worker_CommandResponseDeserialize,
    pub command_response_serialize: Worker_CommandResponseSerialize,
    pub component_data_free: Worker_ComponentDataFree,
    pub component_data_copy: Worker_ComponentDataCopy,
    pub component_data_deserialize: Worker_ComponentDataDeserialize,
    pub component_data_serialize: Worker_ComponentDataSerialize,
    pub component_update_free: Worker_ComponentUpdateFree,
    pub component_update_copy: Worker_ComponentUpdateCopy,
    pub component_update_deserialize: Worker_ComponentUpdateDeserialize,
    pub component_update_serialize: Worker_ComponentUpdateSerialize,
}
impl Default for Worker_ComponentVtable {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " An object used to represent a command request by either raw schema data or some user-defined"]
#[doc = " handle type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandRequest {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub command_index: Worker_CommandIndex,
    pub schema_type: *mut Schema_CommandRequest,
    pub user_handle: *mut Worker_CommandRequestHandle,
}
impl Default for Worker_CommandRequest {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " An object used to represent a command response by either raw schema data or some user-defined"]
#[doc = " handle type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandResponse {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub command_index: Worker_CommandIndex,
    pub schema_type: *mut Schema_CommandResponse,
    pub user_handle: *mut Worker_CommandResponseHandle,
}
impl Default for Worker_CommandResponse {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " An object used to represent a component data snapshot by either raw schema data or some"]
#[doc = " user-defined handle type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentData {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_ComponentData,
    pub user_handle: *mut Worker_ComponentDataHandle,
}
impl Default for Worker_ComponentData {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " An object used to represent a component update by either raw schema data or some user-defined"]
#[doc = " handle type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentUpdate {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_ComponentUpdate,
    pub user_handle: *mut Worker_ComponentUpdateHandle,
}
impl Default for Worker_ComponentUpdate {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Acquire a reference to extend the lifetime of a command request managed by the SDK, by returning"]
    #[doc = " a new command request container object _not_ managed by the SDK. The data contained within the"]
    #[doc = " object will be identical to the original data, but it is not safe to mutate the contained data"]
    #[doc = " without explicitly copying it first. The lifetime of the original container object is unchanged."]
    pub fn Worker_AcquireCommandRequest(
        request: *const Worker_CommandRequest,
    ) -> *mut Worker_CommandRequest;
}
extern "C" {
    #[doc = " Acquire a reference to extend the lifetime of a command response managed by the SDK, by"]
    #[doc = " returning a new command response container object _not_ managed by the SDK. The data contained"]
    #[doc = " within the object will be identical to the original data, but it is not safe to mutate the"]
    #[doc = " contained data without explicitly copying it first. The lifetime of the original container object"]
    #[doc = " is unchanged."]
    pub fn Worker_AcquireCommandResponse(
        response: *const Worker_CommandResponse,
    ) -> *mut Worker_CommandResponse;
}
extern "C" {
    #[doc = " Acquire a reference to extend the lifetime of some component data managed by the SDK, by"]
    #[doc = " returning a new component data container object _not_ managed by the SDK. The data contained"]
    #[doc = " within the object will be identical to the original data, but it is not safe to mutate the"]
    #[doc = " contained data without explicitly copying it first. The lifetime of the original container object"]
    #[doc = " is unchanged."]
    pub fn Worker_AcquireComponentData(
        data: *const Worker_ComponentData,
    ) -> *mut Worker_ComponentData;
}
extern "C" {
    #[doc = " Acquire a reference to extend the lifetime of a component update managed by the SDK, by"]
    #[doc = " returning a new component update container object _not_ managed by the SDK. The data contained"]
    #[doc = " within the object will be identical to the original data, but it is not safe to mutate the"]
    #[doc = " contained data without explicitly copying it first. The lifetime of the original container object"]
    #[doc = " is unchanged."]
    pub fn Worker_AcquireComponentUpdate(
        update: *const Worker_ComponentUpdate,
    ) -> *mut Worker_ComponentUpdate;
}
extern "C" {
    #[doc = " Release a reference obtained by Worker_AcquireCommandRequest."]
    pub fn Worker_ReleaseCommandRequest(request: *mut Worker_CommandRequest);
}
extern "C" {
    #[doc = " Release a reference obtained by Worker_AcquireCommandResponse."]
    pub fn Worker_ReleaseCommandResponse(response: *mut Worker_CommandResponse);
}
extern "C" {
    #[doc = " Release a reference obtained by Worker_AcquireComponentData."]
    pub fn Worker_ReleaseComponentData(data: *mut Worker_ComponentData);
}
extern "C" {
    #[doc = " Release a reference obtained by Worker_AcquireComponentUpdate."]
    pub fn Worker_ReleaseComponentUpdate(update: *mut Worker_ComponentUpdate);
}
#[doc = " Represents an entity with an ID and a component data snapshot."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Entity {
    #[doc = " The ID of the entity."]
    pub entity_id: Worker_EntityId,
    #[doc = " Number of components for the entity."]
    pub component_count: u32,
    #[doc = " Array of initial component data for the entity."]
    pub components: *const Worker_ComponentData,
}
impl Default for Worker_Entity {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_ENTITY_ID: Worker_ConstraintType = 1;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_COMPONENT: Worker_ConstraintType = 2;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_SPHERE: Worker_ConstraintType = 3;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_AND: Worker_ConstraintType = 4;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_OR: Worker_ConstraintType = 5;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_NOT: Worker_ConstraintType = 6;
pub type Worker_ConstraintType = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_EntityIdConstraint {
    pub entity_id: Worker_EntityId,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_ComponentConstraint {
    pub component_id: Worker_ComponentId,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_SphereConstraint {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub radius: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_AndConstraint {
    pub constraint_count: u32,
    pub constraints: *mut Worker_Constraint,
}
impl Default for Worker_AndConstraint {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_OrConstraint {
    pub constraint_count: u32,
    pub constraints: *mut Worker_Constraint,
}
impl Default for Worker_OrConstraint {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_NotConstraint {
    pub constraint: *mut Worker_Constraint,
}
impl Default for Worker_NotConstraint {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Worker_Constraint_Union {
    pub entity_id_constraint: Worker_EntityIdConstraint,
    pub component_constraint: Worker_ComponentConstraint,
    pub sphere_constraint: Worker_SphereConstraint,
    pub and_constraint: Worker_AndConstraint,
    pub or_constraint: Worker_OrConstraint,
    pub not_constraint: Worker_NotConstraint,
    _bindgen_union_align: [u64; 4usize],
}
impl Default for Worker_Constraint_Union {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A single query constraint."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Worker_Constraint {
    #[doc = " The type of constraint, defined using Worker_ConstraintType."]
    pub constraint_type: u8,
    #[doc = " Union with fields corresponding to each constraint type."]
    pub constraint: Worker_Constraint_Union,
}
impl Default for Worker_Constraint {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const Worker_ResultType_WORKER_RESULT_TYPE_COUNT: Worker_ResultType = 1;
pub const Worker_ResultType_WORKER_RESULT_TYPE_SNAPSHOT: Worker_ResultType = 2;
pub type Worker_ResultType = u32;
#[doc = " An entity query."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Worker_EntityQuery {
    #[doc = " The constraint for this query."]
    pub constraint: Worker_Constraint,
    #[doc = " Result type for this query, using Worker_ResultType."]
    pub result_type: u8,
    #[doc = " Number of component IDs in the array for a snapshot result type."]
    pub snapshot_result_type_component_id_count: u32,
    #[doc = " Pointer to component ID data for a snapshot result type. NULL means all component IDs."]
    pub snapshot_result_type_component_ids: *const Worker_ComponentId,
}
impl Default for Worker_EntityQuery {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " An interest override for a particular (entity ID, component ID) pair."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_InterestOverride {
    #[doc = " The ID of the component for which interest is being overridden."]
    pub component_id: u32,
    #[doc = " Whether the worker is interested in this component."]
    pub is_interested: u8,
}
#[doc = " Worker attributes that are part of a worker's runtime configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_WorkerAttributes {
    #[doc = " Number of worker attributes."]
    pub attribute_count: u32,
    #[doc = " Will be NULL if there are no attributes associated with the worker."]
    pub attributes: *mut *const ::std::os::raw::c_char,
}
impl Default for Worker_WorkerAttributes {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for a disconnect message from the SDK."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DisconnectOp {
    #[doc = " A value from the Worker_ConnectionStatusCode enumeration."]
    pub connection_status_code: u8,
    #[doc = " A string giving detailed information on the reason for disconnecting."]
    pub reason: *const ::std::os::raw::c_char,
}
impl Default for Worker_DisconnectOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for a FlagUpdate operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_FlagUpdateOp {
    #[doc = " The name of the updated worker flag."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The new value of the updated worker flag."]
    #[doc = " A null value indicates that the flag has been deleted."]
    pub value: *const ::std::os::raw::c_char,
}
impl Default for Worker_FlagUpdateOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for a log message from the SDK."]
#[doc = " Note: Worker_LogMessageOp has been deprecated and will be removed in a future version of"]
#[doc = " SpatialOS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LogMessageOp {
    #[doc = " The severity of the log message; defined in the Worker_LogLevel enumeration."]
    pub level: u8,
    #[doc = " The message."]
    pub message: *const ::std::os::raw::c_char,
}
impl Default for Worker_LogMessageOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for a set of built-in metrics reported by the SDK."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_MetricsOp {
    pub metrics: Worker_Metrics,
}
impl Default for Worker_MetricsOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for a critical section boundary (enter or leave) operation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_CriticalSectionOp {
    #[doc = " Whether the protocol is entering a critical section (true) or leaving it (false)."]
    pub in_critical_section: u8,
}
#[doc = " Data for an AddEntity operation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_AddEntityOp {
    #[doc = " The ID of the entity that was added to the worker's view of the simulation."]
    pub entity_id: Worker_EntityId,
}
#[doc = " Data for a RemoveEntity operation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_RemoveEntityOp {
    #[doc = " The ID of the entity that was removed from the worker's view of the simulation."]
    pub entity_id: Worker_EntityId,
}
#[doc = " Data for a ReserveEntityIdsResponse operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ReserveEntityIdsResponseOp {
    #[doc = " The ID of the reserve entity ID request for which there was a response."]
    pub request_id: Worker_RequestId,
    #[doc = " Status code of the response, using Worker_StatusCode."]
    pub status_code: u8,
    #[doc = " The error message."]
    pub message: *const ::std::os::raw::c_char,
    #[doc = " If successful, an ID which is the first in a contiguous range of newly allocated entity"]
    #[doc = " IDs which are guaranteed to be unused in the current deployment."]
    pub first_entity_id: Worker_EntityId,
    #[doc = " If successful, the number of IDs reserved in the contiguous range, otherwise 0."]
    pub number_of_entity_ids: u32,
}
impl Default for Worker_ReserveEntityIdsResponseOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for a CreateEntity operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CreateEntityResponseOp {
    #[doc = " The ID of the request for which there was a response."]
    pub request_id: Worker_RequestId,
    #[doc = " Status code of the response, using Worker_StatusCode."]
    pub status_code: u8,
    #[doc = " The error message."]
    pub message: *const ::std::os::raw::c_char,
    #[doc = " If successful, the entity ID of the newly created entity."]
    pub entity_id: Worker_EntityId,
}
impl Default for Worker_CreateEntityResponseOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for a DeleteEntity operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DeleteEntityResponseOp {
    #[doc = " The ID of the delete entity request for which there was a command response."]
    pub request_id: Worker_RequestId,
    #[doc = " The ID of the target entity of this request."]
    pub entity_id: Worker_EntityId,
    #[doc = " Status code of the response, using Worker_StatusCode."]
    pub status_code: u8,
    #[doc = " The error message."]
    pub message: *const ::std::os::raw::c_char,
}
impl Default for Worker_DeleteEntityResponseOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A response indicating the result of an entity query request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_EntityQueryResponseOp {
    #[doc = " The ID of the entity query request for which there was a response."]
    pub request_id: Worker_RequestId,
    #[doc = " Status code of the response, using Worker_StatusCode."]
    pub status_code: u8,
    #[doc = " The error message."]
    pub message: *const ::std::os::raw::c_char,
    #[doc = " Number of entities in the result set. Reused to indicate the result itself for CountResultType"]
    #[doc = " queries."]
    pub result_count: u32,
    #[doc = " Array of entities in the result set. Will be NULL if the query was a count query. Snapshot data"]
    #[doc = " in the result is deserialized with the corresponding vtable deserialize function and freed with"]
    #[doc = " the vtable free function when the OpList is destroyed."]
    pub results: *const Worker_Entity,
}
impl Default for Worker_EntityQueryResponseOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for an AddComponent operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_AddComponentOp {
    #[doc = " The ID of the entity for which a component was added."]
    pub entity_id: Worker_EntityId,
    #[doc = " The initial data for the new component. Deserialized with the corresponding vtable deserialize"]
    #[doc = " function and freed with the vtable free function when the OpList is destroyed."]
    pub data: Worker_ComponentData,
}
impl Default for Worker_AddComponentOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for a RemoveComponent operation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_RemoveComponentOp {
    #[doc = " The ID of the entity for which a component was removed."]
    pub entity_id: Worker_EntityId,
    #[doc = " The ID of the component that was removed."]
    pub component_id: Worker_ComponentId,
}
#[doc = " Data for an AuthorityChange operation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_AuthorityChangeOp {
    #[doc = " The ID of the entity for which there was an authority change."]
    pub entity_id: Worker_EntityId,
    #[doc = " The ID of the component over which the worker's authority has changed."]
    pub component_id: Worker_ComponentId,
    #[doc = " The authority state of the component, using the Worker_Authority enumeration."]
    pub authority: u8,
}
#[doc = " Data for a ComponentUpdate operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentUpdateOp {
    #[doc = " The ID of the entity for which there was a component update."]
    pub entity_id: Worker_EntityId,
    #[doc = " The new component data for the updated entity. Deserialized with the corresponding vtable"]
    #[doc = " deserialize function and freed with the vtable free function when the OpList is destroyed."]
    pub update: Worker_ComponentUpdate,
}
impl Default for Worker_ComponentUpdateOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for a CommandRequest operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandRequestOp {
    #[doc = " The incoming command request ID."]
    pub request_id: Worker_RequestId,
    #[doc = " The ID of the entity for which there was a command request."]
    pub entity_id: Worker_EntityId,
    #[doc = " Upper bound on request timeout provided by the platform."]
    pub timeout_millis: u32,
    #[doc = " The ID of the worker that sent the request."]
    pub caller_worker_id: *const ::std::os::raw::c_char,
    #[doc = " The attributes of the worker that sent the request."]
    pub caller_attribute_set: Worker_WorkerAttributes,
    #[doc = " The command request data. Deserialized with the corresponding vtable deserialize function and"]
    #[doc = " freed with the vtable free function when the OpList is destroyed."]
    pub request: Worker_CommandRequest,
}
impl Default for Worker_CommandRequestOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for a CommandResponse operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandResponseOp {
    #[doc = " The ID of the command request for which there was a command response."]
    pub request_id: Worker_RequestId,
    #[doc = " The ID of the entity originally targeted by the command request."]
    pub entity_id: Worker_EntityId,
    #[doc = " Status code of the response, using Worker_StatusCode."]
    pub status_code: u8,
    #[doc = " The error message."]
    pub message: *const ::std::os::raw::c_char,
    #[doc = " The command response data. Deserialized with the corresponding vtable deserialize function and"]
    #[doc = " freed with the vtable free function when the OpList is destroyed."]
    pub response: Worker_CommandResponse,
}
impl Default for Worker_CommandResponseOp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const Worker_OpType_WORKER_OP_TYPE_DISCONNECT: Worker_OpType = 1;
pub const Worker_OpType_WORKER_OP_TYPE_FLAG_UPDATE: Worker_OpType = 2;
pub const Worker_OpType_WORKER_OP_TYPE_LOG_MESSAGE: Worker_OpType = 3;
pub const Worker_OpType_WORKER_OP_TYPE_METRICS: Worker_OpType = 4;
pub const Worker_OpType_WORKER_OP_TYPE_CRITICAL_SECTION: Worker_OpType = 5;
pub const Worker_OpType_WORKER_OP_TYPE_ADD_ENTITY: Worker_OpType = 6;
pub const Worker_OpType_WORKER_OP_TYPE_REMOVE_ENTITY: Worker_OpType = 7;
pub const Worker_OpType_WORKER_OP_TYPE_RESERVE_ENTITY_IDS_RESPONSE: Worker_OpType = 8;
pub const Worker_OpType_WORKER_OP_TYPE_CREATE_ENTITY_RESPONSE: Worker_OpType = 9;
pub const Worker_OpType_WORKER_OP_TYPE_DELETE_ENTITY_RESPONSE: Worker_OpType = 10;
pub const Worker_OpType_WORKER_OP_TYPE_ENTITY_QUERY_RESPONSE: Worker_OpType = 11;
pub const Worker_OpType_WORKER_OP_TYPE_ADD_COMPONENT: Worker_OpType = 12;
pub const Worker_OpType_WORKER_OP_TYPE_REMOVE_COMPONENT: Worker_OpType = 13;
pub const Worker_OpType_WORKER_OP_TYPE_AUTHORITY_CHANGE: Worker_OpType = 14;
pub const Worker_OpType_WORKER_OP_TYPE_COMPONENT_UPDATE: Worker_OpType = 15;
pub const Worker_OpType_WORKER_OP_TYPE_COMMAND_REQUEST: Worker_OpType = 16;
pub const Worker_OpType_WORKER_OP_TYPE_COMMAND_RESPONSE: Worker_OpType = 17;
#[doc = " Enum defining different possible op types."]
pub type Worker_OpType = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union Worker_Op_Union {
    pub disconnect: Worker_DisconnectOp,
    pub flag_update: Worker_FlagUpdateOp,
    pub log_message: Worker_LogMessageOp,
    pub metrics: Worker_MetricsOp,
    pub critical_section: Worker_CriticalSectionOp,
    pub add_entity: Worker_AddEntityOp,
    pub remove_entity: Worker_RemoveEntityOp,
    pub reserve_entity_ids_response: Worker_ReserveEntityIdsResponseOp,
    pub create_entity_response: Worker_CreateEntityResponseOp,
    pub delete_entity_response: Worker_DeleteEntityResponseOp,
    pub entity_query_response: Worker_EntityQueryResponseOp,
    pub add_component: Worker_AddComponentOp,
    pub remove_component: Worker_RemoveComponentOp,
    pub authority_change: Worker_AuthorityChangeOp,
    pub component_update: Worker_ComponentUpdateOp,
    pub command_request: Worker_CommandRequestOp,
    pub command_response: Worker_CommandResponseOp,
    _bindgen_union_align: [u64; 10usize],
}
impl Default for Worker_Op_Union {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Data for a single op contained within an op list."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Worker_Op {
    #[doc = " The type of this op, defined in Worker_OpType."]
    pub op_type: u8,
    pub op: Worker_Op_Union,
}
impl Default for Worker_Op {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " An op list, usually returned by Worker_Connection_GetOpList."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_OpList {
    pub ops: *mut Worker_Op,
    pub op_count: u32,
}
impl Default for Worker_OpList {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const Worker_NetworkSecurityType_WORKER_NETWORK_SECURITY_TYPE_INSECURE:
    Worker_NetworkSecurityType = 0;
pub const Worker_NetworkSecurityType_WORKER_NETWORK_SECURITY_TYPE_DTLS: Worker_NetworkSecurityType =
    1;
#[doc = " Enum defining the possible network security types."]
pub type Worker_NetworkSecurityType = u32;
#[doc = " Parameters for configuring a RakNet connection. Used by Worker_NetworkParameters."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_RakNetNetworkParameters {
    #[doc = " Time (in milliseconds) that RakNet should use for its heartbeat protocol."]
    pub heartbeat_timeout_millis: u32,
}
#[doc = " Parameters for configuring a TCP connection. Used by Worker_NetworkParameters."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_TcpNetworkParameters {
    #[doc = " The number of multiplexed TCP connections to use."]
    pub multiplex_level: u8,
    #[doc = " Size in bytes of the TCP send buffer."]
    pub send_buffer_size: u32,
    #[doc = " Size in bytes of the TCP receive buffer."]
    pub receive_buffer_size: u32,
    #[doc = " Whether to enable TCP_NODELAY."]
    pub no_delay: u8,
}
#[doc = " Parameters to configure erasure coding, a forward error correction technique which"]
#[doc = " increases bandwidth usage but may improve latency on unreliable networks."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_ErasureCodecParameters {
    #[doc = " Number of consecutive packets to send before sending redundant recovery packets."]
    pub original_packet_count: u8,
    #[doc = " Number of redundant recovery packets to send for each group of consecutive original"]
    #[doc = " packets. These packets are used to recover up to the same number of lost original packets."]
    pub recovery_packet_count: u8,
    #[doc = " Number of batches that can be stored in memory, where a batch contains packets belonging to"]
    #[doc = " the same group of consecutive original packets and the corresponding recovery packets. Each"]
    #[doc = " batch contains up to OriginalPacketCount plus RecoveryPacketCount packets."]
    pub window_size: u8,
}
#[doc = " Parameters to configure flow control. Used by Worker_ModularUdpNetworkParameters."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_Alpha_FlowControlParameters {
    #[doc = " The maximum number of bytes of serialized messages sent by SpatialOS which can be held in"]
    #[doc = " memory on the worker at any one time."]
    pub downstream_window_size_bytes: u32,
    #[doc = " The maximum number of bytes of serialized messages sent by the worker which can be held in"]
    #[doc = " memory on the bridge at any one time."]
    pub upstream_window_size_bytes: u32,
}
#[doc = " Parameters to configure internal heartbeating which can detect unresponsive peers. If an"]
#[doc = " unresponsive peer is detected, a Worker_DisconnectOp will be enqueued in the op list."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_HeartbeatParameters {
    #[doc = " Minimum interval, in milliseconds, between which heartbeat messages are sent to the"]
    #[doc = " peer. A new heartbeat won't be sent before a response for the original heartbeat is received."]
    pub interval_millis: u64,
    #[doc = " Time, in milliseconds, after which the peer will be deemed unresponsive."]
    pub timeout_millis: u64,
}
#[doc = " Parameters for configuring a KCP connection. Used by Worker_NetworkParameters."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_KcpNetworkParameters {
    #[doc = " Whether to enable fast retransmission, which causes retransmission delays to increase more"]
    #[doc = " slowly when retransmitting timed-out packets multiple times."]
    pub fast_retransmission: u8,
    #[doc = " Whether to enable early retransmission, which causes optimistic retransmission of earlier"]
    #[doc = " packets when acknowledgements are received for packets which were sent later, rather than"]
    #[doc = " waiting until the retransmission timeout has expired."]
    pub early_retransmission: u8,
    #[doc = " Whether to enable non-concessional flow control, which disables the usage of"]
    #[doc = " congestion windows (which are used to reduce packet loss across congested networks)."]
    #[doc = " Enabling non-concessional flow control can help optimize for low-latency delivery of"]
    #[doc = " small messages."]
    pub non_concessional_flow_control: u8,
    #[doc = " Number of multiplexed KCP streams."]
    pub multiplex_level: u32,
    #[doc = " Interval, in milliseconds, between which the KCP transport layer sends and receives"]
    #[doc = " packets waiting in its send and receive buffers respectively."]
    pub update_interval_millis: u32,
    #[doc = " Hard limit on the minimum retransmission timeout. A packet will be resent if an"]
    #[doc = " acknowledgment has not been received from the peer within a time period known as the"]
    #[doc = " retransmission timeout. The retransmission timeout is calculated based on estimated round"]
    #[doc = " trip times to the remote peer, but it will never be set to a value lower than the minimum"]
    #[doc = " retransmission timeout. If you set this parameter to a value which is much higher than the"]
    #[doc = " average round trip time to a peer, it will likely result in packets not being resent"]
    #[doc = " as early as they could be, increasing latency for retransmitted packets. However, if you set"]
    #[doc = " this parameter to a value which is lower than the average round trip time (or ping), packets"]
    #[doc = " will be retransmitted even if they are not lost, which will cause unnecessary bandwidth"]
    #[doc = " overhead until round trip times are calculated. For more information on retransmission"]
    #[doc = " timeouts and their calculation, see https://tools.ietf.org/html/rfc6298. Note,"]
    #[doc = " however, that the RFC pertains to TCP, and therefore it focuses on avoiding unnecessary"]
    #[doc = " retransmissions rather than optimizing for latency."]
    #[doc = " Set to zero to use default, which is lower when"]
    #[doc = " Worker_KcpNetworkParameters::fast_retransmission is enabled."]
    pub min_rto_millis: u32,
    #[doc = " KCP flow control window size for sending, in number of KCP packets. This window is applied"]
    #[doc = " to sending across all streams i.e. sending a message will block if it would cause the total"]
    #[doc = " number of un-acked outgoing packets to exceed the send window size."]
    pub send_window_size: u32,
    #[doc = " KCP flow control window for receiving, in number of KCP packets. The upper bound on the"]
    #[doc = " memory used by receive buffers is proportional to the multiplex level multiplied by the"]
    #[doc = " receive window size."]
    pub recv_window_size: u32,
    #[doc = " Whether to enable the erasure codec."]
    pub enable_erasure_codec: u8,
    #[doc = " Erasure codec parameters."]
    pub erasure_codec: Worker_ErasureCodecParameters,
    #[doc = " Heartbeat parameters."]
    pub heartbeat: Worker_HeartbeatParameters,
}
#[doc = " Parameters for configuring KCP for a modular UDP connection. Used by"]
#[doc = " Worker_Alpha_ModularUdpNetworkParameters."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_Alpha_KcpParameters {
    #[doc = " Whether to enable fast retransmission, which causes retransmission delays to increase more"]
    #[doc = " slowly when retransmitting timed-out packets multiple times."]
    pub fast_retransmission: u8,
    #[doc = " Whether to enable early retransmission, which causes optimistic retransmission of earlier"]
    #[doc = " packets when acknowledgements are received for packets which were sent later, rather than"]
    #[doc = " waiting until the retransmission timeout has expired."]
    pub early_retransmission: u8,
    #[doc = " Whether to enable non-concessional flow control, which disables the usage of"]
    #[doc = " congestion windows (which are used to reduce packet loss across congested networks)."]
    #[doc = " Enabling non-concessional flow control can help optimize for low-latency delivery of"]
    #[doc = " small messages."]
    pub non_concessional_flow_control: u8,
    #[doc = " Number of multiplexed KCP streams."]
    pub multiplex_level: u32,
    #[doc = " Interval, in milliseconds, between which the KCP transport layer sends and receives"]
    #[doc = " packets waiting in its send and receive buffers respectively."]
    pub update_interval_millis: u32,
    #[doc = " Hard limit on the minimum retransmission timeout. A packet will be resent if an"]
    #[doc = " acknowledgment has not been received from the peer within a time period known as the"]
    #[doc = " retransmission timeout. The retransmission timeout is calculated based on estimated round"]
    #[doc = " trip times to the remote peer, but it will never be set to a value lower than the minimum"]
    #[doc = " retransmission timeout. If you set this parameter to a value which is much higher than the"]
    #[doc = " average round trip time to a peer, it will likely result in packets not being resent"]
    #[doc = " as early as they could be, increasing latency for retransmitted packets. However, if you set"]
    #[doc = " this parameter to a value which is lower than the average round trip time (or ping), packets"]
    #[doc = " will be retransmitted even if they are not lost, which will cause unnecessary bandwidth"]
    #[doc = " overhead until round trip times are calculated. For more information on retransmission"]
    #[doc = " timeouts and their calculation, see https://tools.ietf.org/html/rfc6298. Note,"]
    #[doc = " however, that the RFC pertains to TCP, and therefore it focuses on avoiding unnecessary"]
    #[doc = " retransmissions rather than optimizing for latency."]
    #[doc = " Set to zero to use default, which is lower when"]
    #[doc = " Worker_KcpNetworkParameters::fast_retransmission is enabled."]
    pub min_rto_millis: u32,
}
#[doc = " Parameters for configuring a modular UDP connection. Used by Worker_NetworkParameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_ModularUdpNetworkParameters {
    #[doc = " Type of encryption layer security to use, defined in Worker_NetworkSecurityType"]
    pub security_type: u8,
    #[doc = " KCP parameters for messages sent from the bridge to the worker."]
    pub downstream_kcp: *const Worker_Alpha_KcpParameters,
    #[doc = " KCP parameters for messages sent from the worker to the bridge."]
    pub upstream_kcp: *const Worker_Alpha_KcpParameters,
    #[doc = " Erasure codec parameters for messages sent from the bridge to the worker."]
    pub downstream_erasure_codec: *const Worker_ErasureCodecParameters,
    #[doc = " Erasure codec parameters for messages sent from the worker to the bridge."]
    pub upstream_erasure_codec: *const Worker_ErasureCodecParameters,
    #[doc = " Heartbeat parameters for heartbeats from the bridge to the worker."]
    pub downstream_heartbeat: *const Worker_HeartbeatParameters,
    #[doc = " Heartbeat parameters for heartbeats from the worker to the bridge."]
    pub upstream_heartbeat: *const Worker_HeartbeatParameters,
    #[doc = " Flow control parameters."]
    pub flow_control: *const Worker_Alpha_FlowControlParameters,
}
impl Default for Worker_Alpha_ModularUdpNetworkParameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Use this flag to connect over TCP."]
pub const Worker_NetworkConnectionType_WORKER_NETWORK_CONNECTION_TYPE_TCP:
    Worker_NetworkConnectionType = 0;
#[doc = " Use this flag to connect over RakNet."]
pub const Worker_NetworkConnectionType_WORKER_NETWORK_CONNECTION_TYPE_RAKNET:
    Worker_NetworkConnectionType = 1;
#[doc = " Use this flag to connect over KCP."]
pub const Worker_NetworkConnectionType_WORKER_NETWORK_CONNECTION_TYPE_KCP:
    Worker_NetworkConnectionType = 2;
#[doc = " Use this flag to connect over a modular UDP stack."]
pub const Worker_NetworkConnectionType_WORKER_NETWORK_CONNECTION_TYPE_MODULAR_UDP:
    Worker_NetworkConnectionType = 3;
#[doc = " Network connection type used by Worker_NetworkParameters."]
pub type Worker_NetworkConnectionType = u32;
#[doc = " Parameters for configuring the network connection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_NetworkParameters {
    #[doc = " Set this flag to non-zero to connect to SpatialOS using the externally-visible IP address. This"]
    #[doc = " flag must be set when connecting externally (i.e. from outside the cloud) to a cloud"]
    #[doc = " deployment."]
    pub use_external_ip: u8,
    #[doc = " Type of network connection to use when connecting to SpatialOS, defined in"]
    #[doc = " Worker_NetworkConnectionType."]
    pub connection_type: u8,
    #[doc = " Parameters used if the WORKER_NETWORK_RAKNET flag is set."]
    pub raknet: Worker_RakNetNetworkParameters,
    #[doc = " Parameters used if the WORKER_NETWORK_TCP flag is set."]
    pub tcp: Worker_TcpNetworkParameters,
    #[doc = " Parameters used if the WORKER_NETWORK_KCP flag is set."]
    pub kcp: Worker_KcpNetworkParameters,
    #[doc = " Parameters used if the WORKER_NETWORK_MODULAR_UDP flag is set."]
    pub modular_udp: Worker_Alpha_ModularUdpNetworkParameters,
    #[doc = " Timeout for the connection to SpatialOS to be established."]
    pub connection_timeout_millis: u64,
    #[doc = " Default timeout for worker commands if one is not specified when command is sent."]
    pub default_command_timeout_millis: u32,
}
impl Default for Worker_NetworkParameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Tuning parameters for configuring protocol logging in the SDK. Used by"]
#[doc = " Worker_ConnectionParameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ProtocolLoggingParameters {
    #[doc = " Log file names are prefixed with this prefix, are numbered, and have the extension .log."]
    pub log_prefix: *const ::std::os::raw::c_char,
    #[doc = " Maximum number of log files to keep. Note that logs from any previous protocol logging"]
    #[doc = " sessions will be overwritten."]
    pub max_log_files: u32,
    #[doc = " Once the size of a log file reaches this size, a new log file is created."]
    pub max_log_file_size_bytes: u32,
}
impl Default for Worker_ProtocolLoggingParameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Parameters for configuring thread affinity. Affinity masks are bit masks where"]
#[doc = " having 1 in the nth least significant position means the thread will be permitted to run"]
#[doc = " on the nth core. If an affinity mask is set to zero, the group of threads using that mask"]
#[doc = " will have no thread affinity. Used by Worker_ConnectionParameters."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_ThreadAffinityParameters {
    #[doc = " Affinity mask for threads related to receiving network ops."]
    pub receive_threads_affinity_mask: u64,
    #[doc = " Affinity mask for threads related to sending network ops."]
    pub send_threads_affinity_mask: u64,
    #[doc = " Affinity mask for short-lived threads."]
    pub temporary_threads_affinity_mask: u64,
}
#[doc = " Parameters for creating a Worker_Connection and connecting to SpatialOS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ConnectionParameters {
    #[doc = " Worker type (platform)."]
    pub worker_type: *const ::std::os::raw::c_char,
    #[doc = " Network parameters."]
    pub network: Worker_NetworkParameters,
    #[doc = " Number of messages that can be stored on the send queue. When the send queue is full, calls to"]
    #[doc = " Worker_Connection_Send functions can block."]
    pub send_queue_capacity: u32,
    #[doc = " Number of messages that can be stored on the receive queue. When the receive queue is full,"]
    #[doc = " SpatialOS can apply QoS and drop messages to the worker."]
    pub receive_queue_capacity: u32,
    #[doc = " Number of messages logged by the SDK that can be stored in the log message queue. When the log"]
    #[doc = " message queue is full, messages logged by the SDK can be dropped."]
    pub log_message_queue_capacity: u32,
    #[doc = " The Connection tracks several internal metrics, such as send and receive queue statistics. This"]
    #[doc = " parameter controls how frequently the Connection will return a MetricsOp reporting its built-in"]
    #[doc = " metrics. If set to zero, this functionality is disabled."]
    pub built_in_metrics_report_period_millis: u32,
    #[doc = " Parameters for configuring protocol parameters."]
    pub protocol_logging: Worker_ProtocolLoggingParameters,
    #[doc = " Whether to enable protocol logging at startup."]
    pub enable_protocol_logging_at_startup: u8,
    #[doc = " Whether to enable dynamic components."]
    #[doc = " If this field is true, add and remove component ops are emitted on authority change. These ops,"]
    #[doc = " like all add and remove component ops, must be treated in an idempotent way (i.e. they replace"]
    #[doc = " any existing value on the worker for the component)."]
    pub enable_dynamic_components: u8,
    #[doc = " Parameters for configuring thread affinity."]
    pub thread_affinity: Worker_ThreadAffinityParameters,
    #[doc = " Number of component vtables."]
    pub component_vtable_count: u32,
    #[doc = " Component vtable for each component that the connection will deal with."]
    pub component_vtables: *const Worker_ComponentVtable,
    #[doc = " Default vtable used when a component is not registered. Only used if not NULL."]
    pub default_component_vtable: *const Worker_ComponentVtable,
}
impl Default for Worker_ConnectionParameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Parameters for authenticating using a SpatialOS login token."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LoginTokenCredentials {
    #[doc = " The token would typically be provided on the command-line by the SpatialOS launcher."]
    pub token: *const ::std::os::raw::c_char,
}
impl Default for Worker_LoginTokenCredentials {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Parameters for authenticating using Steam credentials."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SteamCredentials {
    #[doc = " Steam ticket for the steam app ID and publisher key corresponding to the project name specified"]
    #[doc = " in the Worker_LocatorParameters. Typically obtained from the steam APIs."]
    pub ticket: *const ::std::os::raw::c_char,
    #[doc = " Deployment tag to request access for. If non-empty, must match the following regex:"]
    #[doc = " [A-Za-z0-9][A-Za-z0-9_]*"]
    pub deployment_tag: *const ::std::os::raw::c_char,
}
impl Default for Worker_SteamCredentials {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Parameters for authenticating using a Player Identity Token and Login Token."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_PlayerIdentityCredentials {
    #[doc = " Authenticates a user to a single deployment. Obtained from a game authentication server"]
    #[doc = " using a PIT."]
    pub player_identity_token: *const ::std::os::raw::c_char,
    #[doc = " Uniquely identifies a user across deployments, and is provided by a game authentication"]
    #[doc = " server."]
    pub login_token: *const ::std::os::raw::c_char,
}
impl Default for Worker_PlayerIdentityCredentials {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const Worker_LocatorCredentialsTypes_WORKER_LOCATOR_LOGIN_TOKEN_CREDENTIALS:
    Worker_LocatorCredentialsTypes = 1;
pub const Worker_LocatorCredentialsTypes_WORKER_LOCATOR_STEAM_CREDENTIALS:
    Worker_LocatorCredentialsTypes = 2;
pub const Worker_LocatorCredentialsTypes_WORKER_LOCATOR_PLAYER_IDENTITY_CREDENTIALS:
    Worker_LocatorCredentialsTypes = 3;
#[doc = " Locator credentials type used by the Worker_LocatorParameters struct."]
pub type Worker_LocatorCredentialsTypes = u32;
#[doc = " Parameters for authenticating and logging in to a SpatialOS deployment."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LocatorParameters {
    #[doc = " The name of the SpatialOS project."]
    pub project_name: *const ::std::os::raw::c_char,
    #[doc = " Type of credentials to use when authenticating via the Locator, defined in"]
    #[doc = " Worker_LocatorCredentialsTypes"]
    pub credentials_type: u8,
    #[doc = " Parameters used if the WORKER_LOGIN_TOKEN_CREDENTIALS flag is set."]
    pub login_token: Worker_LoginTokenCredentials,
    #[doc = " Parameters used if the WORKER_STEAM_CREDENTIALS flag is set."]
    pub steam: Worker_SteamCredentials,
    #[doc = " The player identity token/login token pair used for authentication."]
    pub player_identity: Worker_PlayerIdentityCredentials,
    #[doc = " Whether to use an insecure (non-TLS) connection for local development."]
    pub use_insecure_connection: u8,
    #[doc = " Parameters for configuring logging."]
    pub logging: Worker_ProtocolLoggingParameters,
    #[doc = " Whether to enable logging for the Locator flow."]
    pub enable_logging: u8,
}
impl Default for Worker_LocatorParameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Details of a specific deployment obtained via Worker_Locator_GetDeploymentListAsync."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Deployment {
    #[doc = " Name of the deployment."]
    pub deployment_name: *const ::std::os::raw::c_char,
    #[doc = " The name of the assembly used by this deployment."]
    pub assembly_name: *const ::std::os::raw::c_char,
    #[doc = " Description of the deployment."]
    pub description: *const ::std::os::raw::c_char,
    #[doc = " Number of users currently connected to the deployment."]
    pub users_connected: u32,
    #[doc = " Total user capacity of the deployment."]
    pub users_capacity: u32,
}
impl Default for Worker_Deployment {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A deployment list obtained via Worker_Locator_GetDeploymentListAsync."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DeploymentList {
    #[doc = " Number of deployments."]
    pub deployment_count: u32,
    #[doc = " Array of deployments."]
    pub deployments: *mut Worker_Deployment,
    #[doc = " Will be non-NULL if an error occurred."]
    pub error: *const ::std::os::raw::c_char,
}
impl Default for Worker_DeploymentList {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A queue status update when connecting to a deployment via Worker_Locator_ConnectAsync."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_QueueStatus {
    #[doc = " Position in the queue. Decreases as we advance to the front of the queue."]
    pub position_in_queue: u32,
    #[doc = " Will be non-NULL if an error occurred."]
    pub error: *const ::std::os::raw::c_char,
}
impl Default for Worker_QueueStatus {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Component update parameters. Used to modify the behaviour of a component update request."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_UpdateParameters {
    #[doc = " Controls how the update is sent back to the worker from which it was sent. Defined in the"]
    #[doc = " Worker_ComponentUpdateLoopback enumeration."]
    pub loopback: u8,
}
#[doc = " Command parameters. Used to modify the behaviour of a command request."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Worker_CommandParameters {
    #[doc = " Allow command requests to bypass the bridge when this worker is authoritative over the target"]
    #[doc = " entity-component."]
    pub allow_short_circuit: u8,
}
#[doc = " Information about status of a network request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ConnectionStatus {
    #[doc = " The status of the request. This value is a member of the enum Worker_ConnectionStatusCode."]
    pub code: u8,
    #[doc = " Detailed, human readable description of the connection status."]
    #[doc = " Will be \"OK\" if no error occurred."]
    pub detail: *const ::std::os::raw::c_char,
}
impl Default for Worker_ConnectionStatus {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " The parameters used when creating a player identity token."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_PlayerIdentityTokenRequest {
    #[doc = " The development authentication token used for exchanging the player identity token."]
    pub development_authentication_token: *const ::std::os::raw::c_char,
    #[doc = " The ID of the player we are generating a PIT for."]
    pub player_id: *const ::std::os::raw::c_char,
    #[doc = " The lifetime duration of the requested PIT. This is an optional field."]
    #[doc = " If the pointer is null, a default value of 24 hours will be used."]
    pub duration_seconds: *const u32,
    #[doc = " The player's display name. This is an optional field."]
    pub display_name: *const ::std::os::raw::c_char,
    #[doc = " Additional metadata that can be stored in the PIT. This is an optional field."]
    #[doc = " You can use this to securely attach extra attributes in a format you choose (e.g. JSON"]
    #[doc = " payload)."]
    pub metadata: *const ::std::os::raw::c_char,
    #[doc = " Whether to use an insecure (non-TLS) connection for local development."]
    #[doc = " An insecure connection must be used when connecting to a local development authentication"]
    #[doc = " service."]
    #[doc = " A secure connection must be used when connecting to a cloud development authentication"]
    #[doc = " service."]
    pub use_insecure_connection: u8,
}
impl Default for Worker_Alpha_PlayerIdentityTokenRequest {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " The result of creating a player identity token."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_PlayerIdentityTokenResponse {
    #[doc = " The returned player identity token."]
    pub player_identity_token: *const ::std::os::raw::c_char,
    #[doc = " The status code and a human readable description of the status of the request."]
    pub status: Worker_ConnectionStatus,
}
impl Default for Worker_Alpha_PlayerIdentityTokenResponse {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " The parameters used when creating a login token."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_LoginTokensRequest {
    #[doc = " The player identity token of the player"]
    pub player_identity_token: *const ::std::os::raw::c_char,
    #[doc = " The worker type for which the requested LTs are scoped for."]
    pub worker_type: *const ::std::os::raw::c_char,
    #[doc = " The lifetime duration of the requested LTs. This is an optional field."]
    #[doc = " If the pointer is null, a default value of 15 minutes will be used."]
    pub duration_seconds: *const u32,
    #[doc = " Whether to use an insecure (non-TLS) connection for local development."]
    #[doc = " An insecure connection must be used when connecting to a local development login service."]
    #[doc = " A secure connection must be used when connecting to a cloud development login service."]
    pub use_insecure_connection: u8,
}
impl Default for Worker_Alpha_LoginTokensRequest {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A single login token with additional details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_LoginTokenDetails {
    #[doc = " The UUID of the deployment."]
    pub deployment_id: *const ::std::os::raw::c_char,
    #[doc = " The name of the deployment"]
    pub deployment_name: *const ::std::os::raw::c_char,
    #[doc = " The number of tags that the deployment contains."]
    pub tag_count: u32,
    #[doc = " The tags that the deployment contains."]
    pub tags: *mut *const ::std::os::raw::c_char,
    #[doc = " The generated login token for this deployment."]
    pub login_token: *const ::std::os::raw::c_char,
}
impl Default for Worker_Alpha_LoginTokenDetails {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A login token list obtained via Worker_Alpha_CreateDevelopmentLoginTokens"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_LoginTokensResponse {
    #[doc = " Number of login tokens."]
    pub login_token_count: u32,
    #[doc = " Array of login tokens."]
    pub login_tokens: *mut Worker_Alpha_LoginTokenDetails,
    #[doc = " The status code and a human readable description of the status of the request."]
    pub status: Worker_ConnectionStatus,
}
impl Default for Worker_Alpha_LoginTokensResponse {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Locator callback typedef."]
pub type Worker_DeploymentListCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        deployment_list: *const Worker_DeploymentList,
    ),
>;
#[doc = " Locator callback typedef."]
pub type Worker_QueueStatusCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        queue_status: *const Worker_QueueStatus,
    ) -> u8,
>;
#[doc = " PIT-creation callback typedef."]
pub type Worker_Alpha_PlayerIdentityTokenResponseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        response: *const Worker_Alpha_PlayerIdentityTokenResponse,
    ),
>;
#[doc = " login token-creation callback typedef."]
pub type Worker_Alpha_LoginTokensResponseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        response: *const Worker_Alpha_LoginTokensResponse,
    ),
>;
#[doc = " Worker flags callback typedef."]
pub type Worker_GetWorkerFlagCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_char,
    ),
>;
pub type Worker_AllocateFunction = ::std::option::Option<
    unsafe extern "C" fn(
        size: usize,
        state: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type Worker_DeallocateFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pointer: *mut ::std::os::raw::c_void,
        size: usize,
        state: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Returns the WORKER_API_VERSION number that was defined when the library was compiled."]
    pub fn Worker_ApiVersion() -> u32;
}
extern "C" {
    #[doc = " Returns the WORKER_API_VERSION string that was defined when the library was compiled."]
    pub fn Worker_ApiVersionStr() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set custom allocation functions and state for managing memory within the API."]
    #[doc = " The allocation function should allocate a block of memory of the size that is given by"]
    #[doc = " the argument and return a pointer to the first byte."]
    #[doc = " The pointer must be suitably aligned to hold an object of any fundamental alignment and"]
    #[doc = " will be released by a matching call to the deallocation function with the same size."]
    #[doc = " If either allocation or deallocation function throws, the application will terminate."]
    #[doc = " Both allocation and deallocation functions must be thread-safe."]
    #[doc = ""]
    #[doc = " You must call Worker_SetAllocator once before any other API calls. Calling it"]
    #[doc = " multiple times or after another API call has been made is undefined behaviour."]
    pub fn Worker_Alpha_SetAllocator(
        allocate: Worker_AllocateFunction,
        deallocate: Worker_DeallocateFunction,
        state: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns a new Worker_ConnectionParameters with default values set."]
    pub fn Worker_DefaultConnectionParameters() -> Worker_ConnectionParameters;
}
extern "C" {
    #[doc = " Creates a client which can be used to connect to a SpatialOS deployment via a locator service."]
    #[doc = " This is the standard flow used to connect a local worker to a cloud deployment."]
    #[doc = ""]
    #[doc = " The hostname would typically be \"locator.improbable.io\"."]
    #[doc = ""]
    #[doc = " The port number is used to connect to the locator service. This should be set to zero if"]
    #[doc = " connecting to a locator service running on the cloud."]
    pub fn Worker_Locator_Create(
        hostname: *const ::std::os::raw::c_char,
        port: u16,
        params: *const Worker_LocatorParameters,
    ) -> *mut Worker_Locator;
}
extern "C" {
    #[doc = " Frees resources for a Worker_Locator created with Worker_Locator_Create."]
    pub fn Worker_Locator_Destroy(locator: *mut Worker_Locator);
}
extern "C" {
    #[doc = " (Deprecated) Queries the current list of deployments for the project given in the"]
    #[doc = " Worker_LocatorParameters."]
    pub fn Worker_Locator_GetDeploymentListAsync(
        locator: *const Worker_Locator,
    ) -> *mut Worker_DeploymentListFuture;
}
extern "C" {
    #[doc = " (Deprecated) Connects to a specific deployment. The deployment name should be obtained by calling"]
    #[doc = " Worker_Locator_GetDeploymentListAsync. The callback should return zero to cancel queuing,"]
    #[doc = " or non-zero to continue queueing."]
    #[doc = ""]
    #[doc = " Returns a Worker_ConnectionFuture that can be used to obtain a Worker_Connection"]
    #[doc = " by using Worker_ConnectionFuture_Get. Caller is responsible for destroying it when no"]
    #[doc = " longer needed by using Worker_ConnectionFuture_Destroy."]
    pub fn Worker_Locator_ConnectAndQueueAsync(
        locator: *const Worker_Locator,
        deployment_name: *const ::std::os::raw::c_char,
        params: *const Worker_ConnectionParameters,
        data: *mut ::std::os::raw::c_void,
        callback: Worker_QueueStatusCallback,
    ) -> *mut Worker_ConnectionFuture;
}
extern "C" {
    #[doc = " Connects to a specific deployment. The deployment is defined by the login token,"]
    #[doc = " which is obtained from a game authentication server, along with a player identity token."]
    #[doc = ""]
    #[doc = " Returns a Worker_ConnectionFuture that can be used to obtain a Worker_Connection"]
    #[doc = " by using Worker_ConnectionFuture_Get. Caller is responsible for destroying it when no"]
    #[doc = " longer needed by using Worker_ConnectionFuture_Destroy."]
    pub fn Worker_Locator_ConnectAsync(
        locator: *const Worker_Locator,
        params: *const Worker_ConnectionParameters,
    ) -> *mut Worker_ConnectionFuture;
}
extern "C" {
    #[doc = " Connect to a SpatialOS deployment via a receptionist. This is the flow used to connect a managed"]
    #[doc = " worker running in the cloud alongside the deployment, and also to connect any local worker to a"]
    #[doc = " (local or remote) deployment via a locally-running receptionist."]
    #[doc = ""]
    #[doc = " The hostname and port would typically be provided by SpatialOS on the command-line, if this is a"]
    #[doc = " managed worker on the cloud, or otherwise be predetermined (e.g. localhost:7777 for the default"]
    #[doc = " receptionist of a locally-running deployment)."]
    #[doc = ""]
    #[doc = " Returns a Worker_ConnectionFuture that can be used to obtain a Worker_Connection"]
    #[doc = " by using Worker_ConnectionFuture_Get. Caller is responsible for destroying it when no"]
    #[doc = " longer needed by using Worker_ConnectionFuture_Destroy."]
    pub fn Worker_ConnectAsync(
        hostname: *const ::std::os::raw::c_char,
        port: u16,
        worker_id: *const ::std::os::raw::c_char,
        params: *const Worker_ConnectionParameters,
    ) -> *mut Worker_ConnectionFuture;
}
extern "C" {
    #[doc = " Destroys a Worker_DeploymentListFuture. Blocks until the future has completed."]
    pub fn Worker_DeploymentListFuture_Destroy(future: *mut Worker_DeploymentListFuture);
}
extern "C" {
    #[doc = " Gets the result of a Worker_DeploymentListFuture, waiting for up to *timeout_millis to"]
    #[doc = " become available (or forever if timeout_millis is NULL)."]
    #[doc = ""]
    #[doc = " It is an error to call this method again once it has succeeded (e.g. not timed out) once."]
    pub fn Worker_DeploymentListFuture_Get(
        future: *mut Worker_DeploymentListFuture,
        timeout_millis: *const u32,
        data: *mut ::std::os::raw::c_void,
        callback: Worker_DeploymentListCallback,
    );
}
extern "C" {
    #[doc = " Calls the Development Authentication Service to generate a PIT."]
    pub fn Worker_Alpha_CreateDevelopmentPlayerIdentityTokenAsync(
        hostname: *const ::std::os::raw::c_char,
        port: u16,
        params: *mut Worker_Alpha_PlayerIdentityTokenRequest,
    ) -> *mut Worker_Alpha_PlayerIdentityTokenResponseFuture;
}
extern "C" {
    #[doc = " Destroys a Worker_Alpha_PlayerIdentityTokenResponseFuture. Blocks until the future has"]
    #[doc = " completed."]
    pub fn Worker_Alpha_PlayerIdentityTokenResponseFuture_Destroy(
        future: *mut Worker_Alpha_PlayerIdentityTokenResponseFuture,
    );
}
extern "C" {
    #[doc = " Gets the result of a Worker_Alpha_PlayerIdentityTokenResponseFuture, waiting for up to"]
    #[doc = " *timeout_millis to become available (or forever if timeout_millis is NULL)."]
    #[doc = ""]
    #[doc = " It is an error to call this method again once it has succeeded (e.g. not timed out) once."]
    pub fn Worker_Alpha_PlayerIdentityTokenResponseFuture_Get(
        future: *mut Worker_Alpha_PlayerIdentityTokenResponseFuture,
        timeout_millis: *const u32,
        data: *mut ::std::os::raw::c_void,
        callback: Worker_Alpha_PlayerIdentityTokenResponseCallback,
    );
}
extern "C" {
    #[doc = " Calls the Development Login Service to generate a login token list."]
    pub fn Worker_Alpha_CreateDevelopmentLoginTokensAsync(
        hostname: *const ::std::os::raw::c_char,
        port: u16,
        params: *mut Worker_Alpha_LoginTokensRequest,
    ) -> *mut Worker_Alpha_LoginTokensResponseFuture;
}
extern "C" {
    #[doc = " Destroys a Worker_Alpha_LoginTokensResponseFuture. Blocks until the future has"]
    #[doc = " completed."]
    pub fn Worker_Alpha_LoginTokensResponseFuture_Destroy(
        future: *mut Worker_Alpha_LoginTokensResponseFuture,
    );
}
extern "C" {
    #[doc = " Gets the result of a Worker_Alpha_LoginTokensResponseFuture, waiting for up to"]
    #[doc = " *timeout_millis to become available (or forever if timeout_millis is NULL)."]
    #[doc = ""]
    #[doc = " It is an error to call this method again once it has succeeded (e.g. not timeout out) once."]
    pub fn Worker_Alpha_LoginTokensResponseFuture_Get(
        future: *mut Worker_Alpha_LoginTokensResponseFuture,
        timeout_millis: *const u32,
        data: *mut ::std::os::raw::c_void,
        callback: Worker_Alpha_LoginTokensResponseCallback,
    );
}
extern "C" {
    #[doc = " Destroys a Worker_ConnectionFuture. Blocks until the future has completed."]
    pub fn Worker_ConnectionFuture_Destroy(future: *mut Worker_ConnectionFuture);
}
extern "C" {
    #[doc = " Gets the result of a Worker_ConnectionFuture, waiting for up to *timeout_millis to"]
    #[doc = " become available (or forever if timeout_millis is NULL). It returns NULL in case of a timeout."]
    #[doc = ""]
    #[doc = " It is an error to call this method again once it has succeeded (e.g. not timed out) once."]
    pub fn Worker_ConnectionFuture_Get(
        future: *mut Worker_ConnectionFuture,
        timeout_millis: *const u32,
    ) -> *mut Worker_Connection;
}
extern "C" {
    #[doc = " Frees resources for a Worker_Connection created with Worker_ConnectAsync or"]
    #[doc = " Worker_Locator_ConnectAsync."]
    pub fn Worker_Connection_Destroy(connection: *mut Worker_Connection);
}
extern "C" {
    #[doc = " Sends a log message from the worker to SpatialOS."]
    pub fn Worker_Connection_SendLogMessage(
        connection: *mut Worker_Connection,
        log_message: *const Worker_LogMessage,
    );
}
extern "C" {
    #[doc = " Sends metrics data for the worker to SpatialOS."]
    pub fn Worker_Connection_SendMetrics(
        connection: *mut Worker_Connection,
        metrics: *const Worker_Metrics,
    );
}
extern "C" {
    #[doc = " Requests SpatialOS to reserve multiple entity IDs."]
    #[doc = ""]
    #[doc = " Note: We do not recommend reserving entity IDs. Instead, we recommend using Worker_SendCreateEntityRequest"]
    #[doc = " without specifying an entity ID. You can then use the automatically assigned entity ID provided in"]
    #[doc = " Worker_CreateEntityResponseOp."]
    pub fn Worker_Connection_SendReserveEntityIdsRequest(
        connection: *mut Worker_Connection,
        number_of_entity_ids: u32,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    #[doc = " Requests SpatialOS to create an entity. If components[i].schema_type is set, ownership is"]
    #[doc = " transferred to the SDK, and components[i].schema_type is set to NULL. If"]
    #[doc = " components[i].schema_type is NULL and components[i].user_handle is set, the entity data is"]
    #[doc = " serialized immediately using the corresponding vtable serialize function."]
    #[doc = ""]
    #[doc = " Returns Worker_RequestId -1 if the component is not registered and the default vtable is"]
    #[doc = " not found."]
    pub fn Worker_Connection_SendCreateEntityRequest(
        connection: *mut Worker_Connection,
        component_count: u32,
        components: *mut Worker_ComponentData,
        entity_id: *const Worker_EntityId,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    #[doc = " Requests SpatialOS to delete an entity."]
    pub fn Worker_Connection_SendDeleteEntityRequest(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    #[doc = " Queries SpatialOS for entity data."]
    #[doc = ""]
    #[doc = " Returns Worker_RequestId -1 if the query constraint or result type are not valid."]
    pub fn Worker_Connection_SendEntityQueryRequest(
        connection: *mut Worker_Connection,
        entity_query: *const Worker_EntityQuery,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    #[doc = " Sends a component update for the given entity to SpatialOS."]
    #[doc = ""]
    #[doc = " If component_update->schema_type is set, ownership is transferred to the SDK, and"]
    #[doc = " component_update->schema_type is set to NULL. If component_udpate->user_handle is set, then it"]
    #[doc = " will be copied with the corresponding vtable copy function, then the copy is later freed with the"]
    #[doc = " vtable free function."]
    #[doc = ""]
    #[doc = " Note that if update_parameters.loopback = 1 or update_parameters = NULL, the component update"]
    #[doc = " operation is added to the operation list and will be returned by a subsequent call to"]
    #[doc = " Worker_Connection_GetOpList."]
    #[doc = ""]
    #[doc = " Returns WORKER_RESULT_FAILURE if the component is not registered and the default vtable is"]
    #[doc = " not found."]
    pub fn Worker_Connection_SendComponentUpdate(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        component_update: *mut Worker_ComponentUpdate,
        update_parameters: *const Worker_UpdateParameters,
    ) -> i8;
}
extern "C" {
    #[doc = " Adds a new component to the given entity in SpatialOS."]
    #[doc = ""]
    #[doc = " If component_data->schema_type is set, ownership is transferred to the SDK, and"]
    #[doc = " component_data->schema_type is set to NULL. If component_data->user_handle is set, then it"]
    #[doc = " will be copied with the corresponding vtable copy function, then the copy is later freed with the"]
    #[doc = " vtable free function."]
    #[doc = ""]
    #[doc = " Note that if update_parameters.loopback = 1 or update_parameters = NULL, the add component"]
    #[doc = " operation is added to the operation list and will be returned by a subsequent call to"]
    #[doc = " Worker_Connection_GetOpList."]
    #[doc = ""]
    #[doc = " Returns WORKER_RESULT_FAILURE if the component is not registered and the default vtable is"]
    #[doc = " not found."]
    pub fn Worker_Connection_SendAddComponent(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        component_data: *mut Worker_ComponentData,
        update_parameters: *const Worker_UpdateParameters,
    ) -> i8;
}
extern "C" {
    #[doc = " Removes a component from a given entity in SpatialOS."]
    #[doc = ""]
    #[doc = " If update_parameters.loopback = 1 or update_parameters = NULL, the remove component operation"]
    #[doc = " is added to the operation list and will be returned by a subsequent call to"]
    #[doc = " Worker_Connection_GetOpList."]
    #[doc = ""]
    #[doc = " In order to use this function, Worker_ConnectionParameters::enable_dynamic_components must be set"]
    #[doc = " to 1 (true)."]
    #[doc = ""]
    #[doc = " This function does not check whether the worker currently has authority over the component, you"]
    #[doc = " must make sure the worker has authority in order to remove the component."]
    pub fn Worker_Connection_SendRemoveComponent(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        component_id: Worker_ComponentId,
        update_parameters: *const Worker_UpdateParameters,
    );
}
extern "C" {
    #[doc = " Sends a command request targeting the given entity and component to SpatialOS. If timeout_millis"]
    #[doc = " is null, the default will be used."]
    #[doc = ""]
    #[doc = " If request->schema_type is set, ownership is transferred to the SDK, and request->schema_type is"]
    #[doc = " set to NULL. If request->user_handle is set, then it will be copied with the corresponding vtable"]
    #[doc = " copy function, then the copy is later freed with the vtable free function."]
    #[doc = ""]
    #[doc = " If command parameters argument is NULL, then command short circuiting will be disabled."]
    #[doc = ""]
    #[doc = " Returns Worker_RequestId -1 if the component is not registered and the default vtable is"]
    #[doc = " not found."]
    pub fn Worker_Connection_SendCommandRequest(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        request: *mut Worker_CommandRequest,
        timeout_millis: *const u32,
        command_parameters: *const Worker_CommandParameters,
    ) -> Worker_RequestId;
}
extern "C" {
    #[doc = " Sends a command response for the given request ID to SpatialOS."]
    #[doc = ""]
    #[doc = " If response->schema_type is set, ownership is transferred to the SDK, and response->schema_type"]
    #[doc = " is set to NULL. If response->user_handle is set, then it will be copied with the corresponding"]
    #[doc = " vtable copy function, then the copy is later freed with the vtable free function."]
    #[doc = ""]
    #[doc = " Returns WORKER_RESULT_FAILURE if the component is not registered and the default vtable is"]
    #[doc = " not found."]
    pub fn Worker_Connection_SendCommandResponse(
        connection: *mut Worker_Connection,
        request_id: Worker_RequestId,
        response: *mut Worker_CommandResponse,
    ) -> i8;
}
extern "C" {
    #[doc = " Sends an explicit failure for the given command request ID to SpatialOS."]
    pub fn Worker_Connection_SendCommandFailure(
        connection: *mut Worker_Connection,
        request_id: Worker_RequestId,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Sends a diff-based component interest update for the given entity to SpatialOS. By default, the"]
    #[doc = " worker receives data for all entities according to the default component interest specified in"]
    #[doc = " its bridge settings. This function allows interest override by (entity ID, component ID) pair to"]
    #[doc = " force the data to either always be sent or never be sent. Note that this does not apply if the"]
    #[doc = " worker is _authoritative_ over a particular (entity ID, component ID) pair, in which case the"]
    #[doc = " data is always sent."]
    pub fn Worker_Connection_SendComponentInterest(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        interest_override: *const Worker_InterestOverride,
        interest_override_count: u32,
    );
}
extern "C" {
    #[doc = " Sends an acknowledgement of the receipt of an AuthorityLossImminent authority change for a"]
    #[doc = " component. Sending the acknowledgement signifies that this worker is ready to lose authority"]
    #[doc = " over the component."]
    pub fn Worker_Connection_SendAuthorityLossImminentAcknowledgement(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        component_id: Worker_ComponentId,
    );
}
extern "C" {
    #[doc = " Enables or disables protocol logging. Logging uses the parameters specified when the connection"]
    #[doc = " was created. Enabling it when already enabled, or disabling it when already disabled, do nothing."]
    #[doc = ""]
    #[doc = " Note that logs from any previous protocol logging sessions will be overwritten."]
    pub fn Worker_Connection_SetProtocolLoggingEnabled(
        connection: *mut Worker_Connection,
        enabled: u8,
    );
}
extern "C" {
    #[doc = " Returns true if the connection has been successfully created and communication is ongoing."]
    #[doc = " DEPRECATED: Equivalent to Worker_Connection_GetConnectionStatusCode(connection) =="]
    #[doc = "             WORKER_CONNECTION_STATUS_CODE_SUCCESS."]
    pub fn Worker_Connection_IsConnected(connection: *const Worker_Connection) -> u8;
}
extern "C" {
    #[doc = " Returns a value from the Worker_ConnectionStatusCode enum. Returns"]
    #[doc = " WORKER_CONNECTION_STATUS_SUCCESS if the connection is connected and usable, otherwise a"]
    #[doc = " value indicating the type of error that occurred."]
    pub fn Worker_Connection_GetConnectionStatusCode(connection: *const Worker_Connection) -> u8;
}
extern "C" {
    #[doc = " Returns a null terminated string containing more detailed information about the connection"]
    #[doc = " status. The returned pointer points to data that is owned by the SDK and will remain valid for"]
    #[doc = " the lifetime of the connection."]
    pub fn Worker_Connection_GetConnectionStatusDetailString(
        connection: *const Worker_Connection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Retrieves the ID of the worker as assigned by the runtime as a null terminated string. The"]
    #[doc = " returned pointer points to data that is owned by the SDK and will remain valid for the lifetime"]
    #[doc = " of the connection. If the connection has failed, then the returned string will be a valid but"]
    #[doc = " empty string."]
    pub fn Worker_Connection_GetWorkerId(
        connection: *const Worker_Connection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Retrieves the attributes associated with the worker at runtime. The result to data that is owned"]
    #[doc = " by the SDK and will remain valid for the lifetime of the connection. If the connection has"]
    #[doc = " failed, then the returned array of strings will be NULL."]
    pub fn Worker_Connection_GetWorkerAttributes(
        connection: *const Worker_Connection,
    ) -> *const Worker_WorkerAttributes;
}
extern "C" {
    #[doc = " Queries the worker flag with the given name. If the worker flag does not exist, the value will"]
    #[doc = " be NULL."]
    #[doc = ""]
    #[doc = " Worker flags are remotely configurable and may change during the runtime of the worker,"]
    #[doc = " including addition and deletion."]
    pub fn Worker_Connection_GetWorkerFlag(
        connection: *const Worker_Connection,
        name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
        callback: Worker_GetWorkerFlagCallback,
    );
}
extern "C" {
    #[doc = " Retrieves the list of operations that have occurred since the last call to this function."]
    #[doc = ""]
    #[doc = " If timeout_millis is non-zero, the function will block until there is at least one operation to"]
    #[doc = " return, or the timeout has been exceeded. If the timeout is exceeded, an empty list will be"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " If timeout_millis is zero the function is non-blocking."]
    #[doc = ""]
    #[doc = " It is the caller's responsibility to destroy the returned Worker_OpList with the"]
    #[doc = " Worker_OpList_Destroy function."]
    #[doc = ""]
    #[doc = " Note: All data contained within the op-list (such as component data or updates) is owned by"]
    #[doc = " Worker_OpList, and must not be passed directly to another function in the SDK, such as"]
    #[doc = " Worker_Connection_SendComponentUpdate, without copying the data first. Otherwise, a double free"]
    #[doc = " could occur."]
    pub fn Worker_Connection_GetOpList(
        connection: *mut Worker_Connection,
        timeout_millis: u32,
    ) -> *mut Worker_OpList;
}
extern "C" {
    #[doc = " Frees resources for Worker_OpList returned by Worker_Connection_GetOpList."]
    pub fn Worker_OpList_Destroy(op_list: *mut Worker_OpList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotParameters {
    #[doc = " Number of component vtables."]
    pub component_vtable_count: u32,
    #[doc = " Component vtable for each component that the connection will deal with."]
    pub component_vtables: *const Worker_ComponentVtable,
    #[doc = " Default vtable used when a component is not registered. Only used if not NULL."]
    pub default_component_vtable: *const Worker_ComponentVtable,
}
impl Default for Worker_SnapshotParameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " The last operation succeeded and the stream is in a good state."]
pub const Worker_StreamState_WORKER_STREAM_STATE_GOOD: Worker_StreamState = 0;
#[doc = " An internal stream error occurred and the stream is not in a usble state."]
pub const Worker_StreamState_WORKER_STREAM_STATE_BAD: Worker_StreamState = 1;
#[doc = " The data processed in the last operation was not valid and the operation failed."]
#[doc = " The stream is still in a usable state."]
pub const Worker_StreamState_WORKER_STREAM_STATE_INVALID_DATA: Worker_StreamState = 2;
#[doc = " The end of file has been reached."]
pub const Worker_StreamState_WORKER_STREAM_STATE_EOF: Worker_StreamState = 3;
#[doc = " Enum to keep track of the state of streams."]
pub type Worker_StreamState = u32;
#[doc = " Struct to keep track of the state of SnapshotInputStreams and SnapshotOutputStreams."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotState {
    #[doc = " Stream state."]
    pub stream_state: u8,
    #[doc = " Error message."]
    pub error_message: *const ::std::os::raw::c_char,
}
impl Default for Worker_SnapshotState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Opens a Worker_SnapshotInputStream. The caller must manage the memory of the"]
    #[doc = " returned Worker_SnapshotInputStream* by calling Worker_SnapshotInputStream to"]
    #[doc = " write the EOF and release resources."]
    #[doc = ""]
    #[doc = " If an error occurs, a pointer to a Worker_SnapshotInputStream is still returned."]
    #[doc = " Calling Worker_SnapshotInputStream_GetError with this pointer will return"]
    #[doc = " an error message describing any error that occured. In the event of an error, the caller still"]
    #[doc = " must release the memory of the Worker_SnapshotInputStream by calling"]
    #[doc = " Worker_SnapshotInputStream."]
    pub fn Worker_SnapshotInputStream_Create(
        filename: *const ::std::os::raw::c_char,
        params: *const Worker_SnapshotParameters,
    ) -> *mut Worker_SnapshotInputStream;
}
extern "C" {
    #[doc = " Closes the SnapshotInputStream and releases its resources."]
    pub fn Worker_SnapshotInputStream_Destroy(input_stream: *mut Worker_SnapshotInputStream);
}
extern "C" {
    #[doc = " Returns zero (false) if the Worker_SnapshotInputStream has reached the EOF"]
    #[doc = " of the Snapshot."]
    pub fn Worker_SnapshotInputStream_HasNext(input_stream: *mut Worker_SnapshotInputStream) -> u8;
}
extern "C" {
    #[doc = " Reads next Worker_Entity* entity from input_stream."]
    #[doc = ""]
    #[doc = " Worker_SnapshotInputStream_ReadEntity manages the memory for the returned entity internally. The"]
    #[doc = " next call to Worker_SnapshotInputStream_ReadEntity or Worker_SnapshotInputStream_Destroy"]
    #[doc = " invalidates this value; use Worker_AcquireComponentData as usual to preserve component data."]
    pub fn Worker_SnapshotInputStream_ReadEntity(
        input_stream: *mut Worker_SnapshotInputStream,
    ) -> *const Worker_Entity;
}
extern "C" {
    #[doc = " Must be called after every Worker_SnapshotInputStream operation to get the state code of the"]
    #[doc = " stream after the previous operation."]
    #[doc = ""]
    #[doc = " Returns a Worker_SnapshotState which contains the stream state code and an error message: if the"]
    #[doc = " code is WORKER_STREAM_STATE_GOOD no error occurred."]
    pub fn Worker_SnapshotInputStream_GetState(
        input_stream: *mut Worker_SnapshotInputStream,
    ) -> Worker_SnapshotState;
}
extern "C" {
    #[doc = " Opens Worker_SnapshotOutputStream stream. The caller must manage the memory of the"]
    #[doc = " returned Worker_SnapshotOutputStream* by calling"]
    #[doc = " Worker_SnapshotOutputStream_Destroy to write the EOF and release resources."]
    #[doc = ""]
    #[doc = " If an error occurs, a pointer to a Worker_SnapshotOutputStream is still returned."]
    #[doc = " Calling Worker_SnapshotOutputStream_GetError with this pointer will return"]
    #[doc = " an error message describing any error that occured. In the event of an error, the caller still"]
    #[doc = " must release the memory of the Worker_SnapshotOutputStream by calling"]
    #[doc = " Worker_SnapshotOutputStream_Destroy."]
    pub fn Worker_SnapshotOutputStream_Create(
        filename: *const ::std::os::raw::c_char,
        params: *const Worker_SnapshotParameters,
    ) -> *mut Worker_SnapshotOutputStream;
}
extern "C" {
    #[doc = " Closes the snapshot output stream and releases its resources."]
    pub fn Worker_SnapshotOutputStream_Destroy(output_stream: *mut Worker_SnapshotOutputStream);
}
extern "C" {
    #[doc = " Writes next entity_id, entity pair from input. Must call Worker_SnapshotOutputStream_GetState and"]
    #[doc = " Worker_SnapshotOutputStream_GetError to get any error that occurred during operation."]
    pub fn Worker_SnapshotOutputStream_WriteEntity(
        output_stream: *mut Worker_SnapshotOutputStream,
        entity: *const Worker_Entity,
    );
}
extern "C" {
    #[doc = " Must be called after every Worker_SnapshotOutputStream operation to get"]
    #[doc = " the state code of the stream after the previous operation."]
    #[doc = ""]
    #[doc = " Returns a Worker_SnapshotState which contains the stream state code and an error"]
    #[doc = " message: if the code is WORKER_STREAM_STATE_GOOD no error occurred."]
    pub fn Worker_SnapshotOutputStream_GetState(
        output_stream: *mut Worker_SnapshotOutputStream,
    ) -> Worker_SnapshotState;
}
