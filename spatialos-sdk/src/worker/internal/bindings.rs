/* automatically generated by rust-bindgen */

pub const SCHEMA_MAP_KEY_FIELD_ID: u32 = 1;
pub const SCHEMA_MAP_VALUE_FIELD_ID: u32 = 2;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const WORKER_DEFAULTS_SEND_QUEUE_CAPACITY: u32 = 4096;
pub const WORKER_DEFAULTS_RECEIVE_QUEUE_CAPACITY: u32 = 4096;
pub const WORKER_DEFAULTS_LOG_MESSAGE_QUEUE_CAPACITY: u32 = 256;
pub const WORKER_DEFAULTS_BUILT_IN_METRICS_REPORT_PERIOD_MILLIS: u32 = 5000;
pub const WORKER_DEFAULTS_CONNECTION_TIMEOUT_MILLIS: u32 = 60000;
pub const WORKER_DEFAULTS_DEFAULT_COMMAND_TIMEOUT_MILLIS: u32 = 5000;
pub const WORKER_DEFAULTS_TCP_MULTIPLEX_LEVEL: u32 = 32;
pub const WORKER_DEFAULTS_TCP_SEND_BUFFER_SIZE: u32 = 65536;
pub const WORKER_DEFAULTS_TCP_RECEIVE_BUFFER_SIZE: u32 = 65536;
pub const WORKER_DEFAULTS_TCP_NO_DELAY: u32 = 0;
pub const WORKER_DEFAULTS_RAKNET_HEARTBEAT_TIMEOUT_MILLIS: u32 = 60000;
pub const WORKER_DEFAULTS_LOG_PREFIX: &'static [u8; 14usize] = b"protocol-log-\0";
pub const WORKER_DEFAULTS_MAX_LOG_FILES: u32 = 10;
pub const WORKER_DEFAULTS_MAX_LOG_FILE_SIZE_BYTES: u32 = 1048576;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type Schema_FieldId = u32;
pub type Schema_EntityId = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_CommandRequest {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_CommandResponse {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_ComponentData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_ComponentUpdate {
    _unused: [u8; 0],
}
/// An object, roughly corresponding to an instance of a "type" as defined in schema.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_Object {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate a command request schema type instance. The component ID should be as defined in
    /// the schema, and the command_index should be the 1-based position of the command in the order
    /// the commands appear in component in the schema.
    pub fn Schema_CreateCommandRequest(
        component_id: Schema_FieldId,
        command_index: Schema_FieldId,
    ) -> *mut Schema_CommandRequest;
}
extern "C" {
    /// Free the resources associated with a command request schema type instance.
    pub fn Schema_DestroyCommandRequest(request: *mut Schema_CommandRequest);
}
extern "C" {
    /// Get the component ID of a command request.
    pub fn Schema_GetCommandRequestComponentId(
        request: *const Schema_CommandRequest,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Get the 1-based position of the command in the order the commands appear in the schema.
    pub fn Schema_GetCommandRequestCommandIndex(
        request: *const Schema_CommandRequest,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Get the command request as a Schema_Object.
    pub fn Schema_GetCommandRequestObject(
        request: *mut Schema_CommandRequest,
    ) -> *mut Schema_Object;
}
extern "C" {
    /// Allocate a command response schema type instance. The component ID should be as defined in
    /// the schema, and the command_index should be the 1-based position of the command in the order
    /// the commands appear in the component in schema.
    pub fn Schema_CreateCommandResponse(
        component_id: Schema_FieldId,
        command_index: Schema_FieldId,
    ) -> *mut Schema_CommandResponse;
}
extern "C" {
    /// Free the resources associated with a command response schema type instance.
    pub fn Schema_DestroyCommandResponse(response: *mut Schema_CommandResponse);
}
extern "C" {
    /// Get the component ID of a command response.
    pub fn Schema_GetCommandResponseComponentId(
        request: *const Schema_CommandResponse,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Get the 1-based position of the command in the order the commands appear in the schema.
    pub fn Schema_GetCommandResponseCommandIndex(
        request: *const Schema_CommandResponse,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Get the command response as a Schema_Object.
    pub fn Schema_GetCommandResponseObject(
        response: *mut Schema_CommandResponse,
    ) -> *mut Schema_Object;
}
extern "C" {
    /// Allocate a component data snapshot schema type instance.
    pub fn Schema_CreateComponentData(component_id: Schema_FieldId) -> *mut Schema_ComponentData;
}
extern "C" {
    /// Free the resources associated with a component data snapshot schema type instance.
    pub fn Schema_DestroyComponentData(data: *mut Schema_ComponentData);
}
extern "C" {
    /// Get the component ID of a component data snapshot.
    pub fn Schema_GetComponentDataComponentId(data: *const Schema_ComponentData) -> Schema_FieldId;
}
extern "C" {
    /// Get the command data snapshot as a Schema_Object.
    pub fn Schema_GetComponentDataFields(data: *mut Schema_ComponentData) -> *mut Schema_Object;
}
extern "C" {
    /// Allocate a component update schema type instance.
    pub fn Schema_CreateComponentUpdate(
        component_id: Schema_FieldId,
    ) -> *mut Schema_ComponentUpdate;
}
extern "C" {
    /// Free the resources associated with a component update schema type instance.
    pub fn Schema_DestroyComponentUpdate(update: *mut Schema_ComponentUpdate);
}
extern "C" {
    /// Get the component ID of a component update.
    pub fn Schema_GetComponentUpdateComponentId(
        update: *const Schema_ComponentUpdate,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Get an object representing the non-event fields in a component update. This object should be used
    /// as if it had one field for each field in the component, whose type corresponds to the type of the
    /// field as defined in schema. Note that when an option, list or map field in a component is set to
    /// the empty value, it will not / should not appear here. Instead, use
    /// Schema_IndexComponentUpdateClearedField and related functions.
    pub fn Schema_GetComponentUpdateFields(
        update: *mut Schema_ComponentUpdate,
    ) -> *mut Schema_Object;
}
extern "C" {
    /// Get an object representing the event fields in a component update. This object should be used
    /// as if it had one field for each event in the component. Each field behaves like a list (may have
    /// multiple instances of the same event), and the field ID of an event is its 1-based position in
    /// the order the events appear in the component in the schema.
    pub fn Schema_GetComponentUpdateEvents(
        update: *mut Schema_ComponentUpdate,
    ) -> *mut Schema_Object;
}
extern "C" {
    /// Clears the list of fields that this update sets to the empty value (for option, list and map
    /// fields in a component).
    pub fn Schema_ClearComponentUpdateClearedFields(update: *mut Schema_ComponentUpdate);
}
extern "C" {
    /// Specifies that this update sets and option, list or map field in a component to the empty
    /// value.
    pub fn Schema_AddComponentUpdateClearedField(
        update: *mut Schema_ComponentUpdate,
        field_id: Schema_FieldId,
    );
}
extern "C" {
    /// Returns the number of option, list and map fields in a component that this update sets to the
    /// empty value.
    pub fn Schema_GetComponentUpdateClearedFieldCount(update: *const Schema_ComponentUpdate)
        -> u32;
}
extern "C" {
    /// Returns the field ID of an option, list or map field which is set to the empty value by this
    /// update.
    pub fn Schema_IndexComponentUpdateClearedField(
        update: *const Schema_ComponentUpdate,
        index: u32,
    ) -> Schema_FieldId;
}
extern "C" {
    /// Returns all field IDs of option, list, or map fields which are set to the empty value by this
    /// component. The output_array should have space for
    /// Schema_GetComponentUpdateClearedFieldCount(update) field IDs.
    pub fn Schema_GetComponentUpdateClearedFieldList(
        update: *const Schema_ComponentUpdate,
        output_array: *mut Schema_FieldId,
    );
}
extern "C" {
    /// Completely clears all fields in the given object.
    pub fn Schema_Clear(object: *mut Schema_Object);
}
extern "C" {
    /// Completely clears the given field ID in the given object.
    pub fn Schema_ClearField(object: *mut Schema_Object, field_id: Schema_FieldId);
}
extern "C" {
    /// Copies all fields from `src` to `dst`. The copy is shallow; changes made to object fields in the
    /// source will also be reflected in the copied fields.
    ///
    /// If `src == dst`, or if the objects are not associated with the same root schema type instance, no
    /// operation is performed.
    pub fn Schema_ShallowCopy(src: *const Schema_Object, dst: *mut Schema_Object);
}
extern "C" {
    /// Copies over a field from `src` to `dst`. If multiple fields with the given field_id exist all
    /// are copied. The copy is shallow; changes made to object fields in the source will also be
    /// reflected in the copied fields.
    ///
    /// If `src == dst`, or if the objects are not associated with the same root schema type instance, no
    /// operation is performed.
    pub fn Schema_ShallowCopyField(
        src: *const Schema_Object,
        dst: *mut Schema_Object,
        field_id: Schema_FieldId,
    );
}
extern "C" {
    /// Allocates an orphaned Schema_Object in memory owned by the given Schema_Object instance. The
    /// returned object is owned by the associated schema type instance, but is not reachable from any
    /// other object. The memory is freed by a call to Schema_Destroy.
    pub fn Schema_AllocateObject(object: *const Schema_Object) -> *mut Schema_Object;
}
extern "C" {
    /// Allocates a buffer of the specified length in bytes from memory owned by the given Schema_Object
    /// instance. The memory is freed by a call to Schema_Destroy.
    ///
    /// Note: this is useful for allocating memory that must live as long as the root schema type
    /// instance, for example to pass to Schema_MergeFromBuffer.
    pub fn Schema_AllocateBuffer(object: *mut Schema_Object, length: u32) -> *mut u8;
}
extern "C" {
    /// Merges the given buffer into the given object, appending all fields. This function
    /// can fail; if the return value is zero, call Schema_GetError to obtain an error string.
    ///
    /// Note: the provided buffer is not copied, and must live as long as the root schema type instance.
    pub fn Schema_MergeFromBuffer(object: *mut Schema_Object, buffer: *const u8, length: u32)
        -> u8;
}
extern "C" {
    /// Computes the serialized length of the given Schema_Object.
    pub fn Schema_GetWriteBufferLength(object: *const Schema_Object) -> u32;
}
extern "C" {
    /// Serializes the given object into the provided buffer, which _must_ have space at
    /// least equal to the length returned by Schema_WriteBufferLength. This function can
    /// fail; if the return value is zero, call Schema_GetError to obtain an error string.
    ///
    /// WriteToBuffer re-calculates the size of the underlying Schema_Object and is therefore less
    /// performant than Schema_SerializeToBuffer. Schema_WriteToBuffer is deprecated and will be removed
    /// in 14+ releases.
    ///
    /// `length` must equal the value returned by `Schema_GetWriteBufferLength`. Otherwise, the behavior
    /// is undefined.
    pub fn Schema_WriteToBuffer(object: *const Schema_Object, buffer: *mut u8) -> u8;
}
extern "C" {
    pub fn Schema_SerializeToBuffer(
        object: *const Schema_Object,
        buffer: *mut u8,
        length: u32,
    ) -> u8;
}
extern "C" {
    /// Returns the number of unique field IDs used in the Schema_Object.
    pub fn Schema_GetUniqueFieldIdCount(object: *const Schema_Object) -> u32;
}
extern "C" {
    /// Returns the sorted list of unique field IDs used in the Schema_Object. The buffer parameter
    /// must have space remaining for as many field IDs as indicated by Schema_GetUniqueFieldIdCount.
    pub fn Schema_GetUniqueFieldIds(object: *const Schema_Object, buffer: *mut u32);
}
extern "C" {
    pub fn Schema_AddFloat(object: *mut Schema_Object, field_id: Schema_FieldId, value: f32);
}
extern "C" {
    pub fn Schema_AddDouble(object: *mut Schema_Object, field_id: Schema_FieldId, value: f64);
}
extern "C" {
    pub fn Schema_AddBool(object: *mut Schema_Object, field_id: Schema_FieldId, value: u8);
}
extern "C" {
    pub fn Schema_AddInt32(object: *mut Schema_Object, field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddInt64(object: *mut Schema_Object, field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddUint32(object: *mut Schema_Object, field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddUint64(object: *mut Schema_Object, field_id: Schema_FieldId, value: u64);
}
extern "C" {
    pub fn Schema_AddSint32(object: *mut Schema_Object, field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddSint64(object: *mut Schema_Object, field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddFixed32(object: *mut Schema_Object, field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddFixed64(object: *mut Schema_Object, field_id: Schema_FieldId, value: u64);
}
extern "C" {
    pub fn Schema_AddSfixed32(object: *mut Schema_Object, field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddSfixed64(object: *mut Schema_Object, field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddEntityId(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        value: Schema_EntityId,
    );
}
extern "C" {
    pub fn Schema_AddEnum(object: *mut Schema_Object, field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddBytes(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        buffer: *const u8,
        length: u32,
    );
}
extern "C" {
    pub fn Schema_AddObject(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
    ) -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_AddFloatList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const f32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddDoubleList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const f64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddBoolList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u8,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddInt32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddInt64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddUint32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddUint64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSint32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSint64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddFixed32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddFixed64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSfixed32List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddSfixed64List(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const i64,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddEntityIdList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const Schema_EntityId,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_AddEnumList(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        values: *const u32,
        count: u32,
    );
}
extern "C" {
    pub fn Schema_GetFloatCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetDoubleCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBoolCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetInt32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetInt64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSint32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSint64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSfixed32Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSfixed64Count(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetEntityIdCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetEnumCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytesCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetObjectCount(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFloat(object: *const Schema_Object, field_id: Schema_FieldId) -> f32;
}
extern "C" {
    pub fn Schema_GetDouble(object: *const Schema_Object, field_id: Schema_FieldId) -> f64;
}
extern "C" {
    pub fn Schema_GetBool(object: *const Schema_Object, field_id: Schema_FieldId) -> u8;
}
extern "C" {
    pub fn Schema_GetInt32(object: *const Schema_Object, field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetInt64(object: *const Schema_Object, field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetUint32(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint64(object: *const Schema_Object, field_id: Schema_FieldId) -> u64;
}
extern "C" {
    pub fn Schema_GetSint32(object: *const Schema_Object, field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetSint64(object: *const Schema_Object, field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetFixed32(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed64(object: *const Schema_Object, field_id: Schema_FieldId) -> u64;
}
extern "C" {
    pub fn Schema_GetSfixed32(object: *const Schema_Object, field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetSfixed64(object: *const Schema_Object, field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetEntityId(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
    ) -> Schema_EntityId;
}
extern "C" {
    pub fn Schema_GetEnum(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytesLength(object: *const Schema_Object, field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytes(object: *const Schema_Object, field_id: Schema_FieldId) -> *const u8;
}
extern "C" {
    pub fn Schema_GetObject(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
    ) -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_IndexFloat(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> f32;
}
extern "C" {
    pub fn Schema_IndexDouble(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> f64;
}
extern "C" {
    pub fn Schema_IndexBool(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Schema_IndexInt32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i32;
}
extern "C" {
    pub fn Schema_IndexInt64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i64;
}
extern "C" {
    pub fn Schema_IndexUint32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexUint64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u64;
}
extern "C" {
    pub fn Schema_IndexSint32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i32;
}
extern "C" {
    pub fn Schema_IndexSint64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i64;
}
extern "C" {
    pub fn Schema_IndexFixed32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexFixed64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u64;
}
extern "C" {
    pub fn Schema_IndexSfixed32(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i32;
}
extern "C" {
    pub fn Schema_IndexSfixed64(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> i64;
}
extern "C" {
    pub fn Schema_IndexEntityId(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> Schema_EntityId;
}
extern "C" {
    pub fn Schema_IndexEnum(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexBytesLength(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> u32;
}
extern "C" {
    pub fn Schema_IndexBytes(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> *const u8;
}
extern "C" {
    pub fn Schema_IndexObject(
        object: *mut Schema_Object,
        field_id: Schema_FieldId,
        index: u32,
    ) -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_GetFloatList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut f32,
    );
}
extern "C" {
    pub fn Schema_GetDoubleList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut f64,
    );
}
extern "C" {
    pub fn Schema_GetBoolList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u8,
    );
}
extern "C" {
    pub fn Schema_GetInt32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i32,
    );
}
extern "C" {
    pub fn Schema_GetInt64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i64,
    );
}
extern "C" {
    pub fn Schema_GetUint32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u32,
    );
}
extern "C" {
    pub fn Schema_GetUint64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u64,
    );
}
extern "C" {
    pub fn Schema_GetSint32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i32,
    );
}
extern "C" {
    pub fn Schema_GetSint64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i64,
    );
}
extern "C" {
    pub fn Schema_GetFixed32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u32,
    );
}
extern "C" {
    pub fn Schema_GetFixed64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u64,
    );
}
extern "C" {
    pub fn Schema_GetSfixed32List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i32,
    );
}
extern "C" {
    pub fn Schema_GetSfixed64List(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut i64,
    );
}
extern "C" {
    pub fn Schema_GetEntityIdList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut Schema_EntityId,
    );
}
extern "C" {
    pub fn Schema_GetEnumList(
        object: *const Schema_Object,
        field_id: Schema_FieldId,
        output_array: *mut u32,
    );
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type Worker_EntityId = i64;
pub type Worker_ComponentId = u32;
pub type Worker_RequestId = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ConnectionFuture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DeploymentListFuture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Locator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnasphotInputStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotOutputStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_Locator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotInputStream {
    _unused: [u8; 0],
}
pub const Worker_LogLevel_WORKER_LOG_LEVEL_DEBUG: Worker_LogLevel = 1;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_INFO: Worker_LogLevel = 2;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_WARN: Worker_LogLevel = 3;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_ERROR: Worker_LogLevel = 4;
pub const Worker_LogLevel_WORKER_LOG_LEVEL_FATAL: Worker_LogLevel = 5;
/// Enum defining the severities of log messages that can be sent to SpatialOS and received from the
/// SDK.
pub type Worker_LogLevel = u32;
pub const Worker_StatusCode_WORKER_STATUS_CODE_SUCCESS: Worker_StatusCode = 1;
pub const Worker_StatusCode_WORKER_STATUS_CODE_TIMEOUT: Worker_StatusCode = 2;
pub const Worker_StatusCode_WORKER_STATUS_CODE_NOT_FOUND: Worker_StatusCode = 3;
pub const Worker_StatusCode_WORKER_STATUS_CODE_AUTHORITY_LOST: Worker_StatusCode = 4;
pub const Worker_StatusCode_WORKER_STATUS_CODE_PERMISSION_DENIED: Worker_StatusCode = 5;
pub const Worker_StatusCode_WORKER_STATUS_CODE_APPLICATION_ERROR: Worker_StatusCode = 6;
pub const Worker_StatusCode_WORKER_STATUS_CODE_INTERNAL_ERROR: Worker_StatusCode = 7;
/// Enum defining possible command status codes.
pub type Worker_StatusCode = u32;
pub const Worker_Authority_WORKER_AUTHORITY_NOT_AUTHORITATIVE: Worker_Authority = 0;
pub const Worker_Authority_WORKER_AUTHORITY_AUTHORITATIVE: Worker_Authority = 1;
pub const Worker_Authority_WORKER_AUTHORITY_AUTHORITY_LOSS_IMMINENT: Worker_Authority = 2;
/// Enum defining the possible authority states for an entity component.
pub type Worker_Authority = u32;
/// Parameters for sending a log message to SpatialOS.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LogMessage {
    /// The severity of the log message; defined in the Worker_LogLevel enumeration.
    pub level: u8,
    /// The name of the logger.
    pub logger_name: *const ::std::os::raw::c_char,
    /// The full log message.
    pub message: *const ::std::os::raw::c_char,
    /// The ID of the entity this message relates to, or NULL for none.
    pub entity_id: *const Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_LogMessage() {
    assert_eq!(
        ::std::mem::size_of::<Worker_LogMessage>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_LogMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_LogMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_LogMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_LogMessage>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LogMessage),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_LogMessage>())).logger_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LogMessage),
            "::",
            stringify!(logger_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_LogMessage>())).message as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LogMessage),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_LogMessage>())).entity_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LogMessage),
            "::",
            stringify!(entity_id)
        )
    );
}
/// Parameters for a gauge metric.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_GaugeMetric {
    pub key: *const ::std::os::raw::c_char,
    pub value: f64,
}
#[test]
fn bindgen_test_layout_Worker_GaugeMetric() {
    assert_eq!(
        ::std::mem::size_of::<Worker_GaugeMetric>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_GaugeMetric))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_GaugeMetric>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_GaugeMetric))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_GaugeMetric>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_GaugeMetric),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_GaugeMetric>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_GaugeMetric),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_HistogramMetricBucket {
    pub upper_bound: f64,
    pub samples: u32,
}
#[test]
fn bindgen_test_layout_Worker_HistogramMetricBucket() {
    assert_eq!(
        ::std::mem::size_of::<Worker_HistogramMetricBucket>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_HistogramMetricBucket))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_HistogramMetricBucket>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_HistogramMetricBucket))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_HistogramMetricBucket>())).upper_bound as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_HistogramMetricBucket),
            "::",
            stringify!(upper_bound)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_HistogramMetricBucket>())).samples as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_HistogramMetricBucket),
            "::",
            stringify!(samples)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_HistogramMetric {
    pub key: *const ::std::os::raw::c_char,
    pub sum: f64,
    pub bucket_count: u32,
    pub buckets: *const Worker_HistogramMetricBucket,
}
#[test]
fn bindgen_test_layout_Worker_HistogramMetric() {
    assert_eq!(
        ::std::mem::size_of::<Worker_HistogramMetric>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_HistogramMetric))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_HistogramMetric>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_HistogramMetric))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_HistogramMetric>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_HistogramMetric),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_HistogramMetric>())).sum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_HistogramMetric),
            "::",
            stringify!(sum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_HistogramMetric>())).bucket_count as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_HistogramMetric),
            "::",
            stringify!(bucket_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_HistogramMetric>())).buckets as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_HistogramMetric),
            "::",
            stringify!(buckets)
        )
    );
}
/// Parameters for sending metrics to SpatialOS.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Metrics {
    /// The load value of this worker. If NULL, do not report load.
    pub load: *const f64,
    /// The number of gauge metrics.
    pub gauge_metric_count: u32,
    /// Array of gauge metrics.
    pub gauge_metrics: *const Worker_GaugeMetric,
    /// The number of histogram metrics.
    pub histogram_metric_count: u32,
    /// Array of histogram metrics.
    pub histogram_metrics: *const Worker_HistogramMetric,
}
#[test]
fn bindgen_test_layout_Worker_Metrics() {
    assert_eq!(
        ::std::mem::size_of::<Worker_Metrics>(),
        40usize,
        concat!("Size of: ", stringify!(Worker_Metrics))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_Metrics>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_Metrics))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_Metrics>())).load as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Metrics),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Metrics>())).gauge_metric_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Metrics),
            "::",
            stringify!(gauge_metric_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_Metrics>())).gauge_metrics as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Metrics),
            "::",
            stringify!(gauge_metrics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Metrics>())).histogram_metric_count as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Metrics),
            "::",
            stringify!(histogram_metric_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Metrics>())).histogram_metrics as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Metrics),
            "::",
            stringify!(histogram_metrics)
        )
    );
}
pub type Worker_CommandRequestHandle = ::std::os::raw::c_void;
pub type Worker_CommandResponseHandle = ::std::os::raw::c_void;
pub type Worker_ComponentDataHandle = ::std::os::raw::c_void;
pub type Worker_ComponentUpdateHandle = ::std::os::raw::c_void;
pub type Worker_CommandRequestFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandRequestHandle,
    ),
>;
pub type Worker_CommandResponseFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandResponseHandle,
    ),
>;
pub type Worker_ComponentDataFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentDataHandle,
    ),
>;
pub type Worker_ComponentUpdateFree = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentUpdateHandle,
    ),
>;
pub type Worker_CommandRequestCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandRequestHandle,
    ) -> *mut Worker_CommandRequestHandle,
>;
pub type Worker_CommandResponseCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandResponseHandle,
    ) -> *mut Worker_CommandResponseHandle,
>;
pub type Worker_ComponentDataCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentDataHandle,
    ) -> *mut Worker_ComponentDataHandle,
>;
pub type Worker_ComponentUpdateCopy = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentUpdateHandle,
    ) -> *mut Worker_ComponentUpdateHandle,
>;
pub type Worker_CommandRequestDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_CommandRequest,
        handle_out: *mut *mut Worker_CommandRequestHandle,
    ) -> u8,
>;
pub type Worker_CommandResponseDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_CommandResponse,
        handle_out: *mut *mut Worker_CommandResponseHandle,
    ) -> u8,
>;
pub type Worker_ComponentDataDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_ComponentData,
        handle_out: *mut *mut Worker_ComponentDataHandle,
    ) -> u8,
>;
pub type Worker_ComponentUpdateDeserialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        source: *mut Schema_ComponentUpdate,
        handle_out: *mut *mut Worker_ComponentUpdateHandle,
    ) -> u8,
>;
pub type Worker_CommandRequestSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandRequestHandle,
        target_out: *mut *mut Schema_CommandRequest,
    ),
>;
pub type Worker_CommandResponseSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_CommandResponseHandle,
        target_out: *mut *mut Schema_CommandResponse,
    ),
>;
pub type Worker_ComponentDataSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentDataHandle,
        target_out: *mut *mut Schema_ComponentData,
    ),
>;
pub type Worker_ComponentUpdateSerialize = ::std::option::Option<
    unsafe extern "C" fn(
        component_id: Worker_ComponentId,
        user_data: *mut ::std::os::raw::c_void,
        handle: *mut Worker_ComponentUpdateHandle,
        target_out: *mut *mut Schema_ComponentUpdate,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentVtable {
    /// Component ID that this vtable is for. If this is the default vtable, this field is ignored.
    pub component_id: Worker_ComponentId,
    /// User data which will be passed directly to the callbacks supplied below.
    pub user_data: *mut ::std::os::raw::c_void,
    pub command_request_free: Worker_CommandRequestFree,
    pub command_request_copy: Worker_CommandRequestCopy,
    pub command_request_deserialize: Worker_CommandRequestDeserialize,
    pub command_request_serialize: Worker_CommandRequestSerialize,
    pub command_response_free: Worker_CommandResponseFree,
    pub command_response_copy: Worker_CommandResponseCopy,
    pub command_response_deserialize: Worker_CommandResponseDeserialize,
    pub command_response_serialize: Worker_CommandResponseSerialize,
    pub component_data_free: Worker_ComponentDataFree,
    pub component_data_copy: Worker_ComponentDataCopy,
    pub component_data_deserialize: Worker_ComponentDataDeserialize,
    pub component_data_serialize: Worker_ComponentDataSerialize,
    pub component_update_free: Worker_ComponentUpdateFree,
    pub component_update_copy: Worker_ComponentUpdateCopy,
    pub component_update_deserialize: Worker_ComponentUpdateDeserialize,
    pub component_update_serialize: Worker_ComponentUpdateSerialize,
}
#[test]
fn bindgen_test_layout_Worker_ComponentVtable() {
    assert_eq!(
        ::std::mem::size_of::<Worker_ComponentVtable>(),
        144usize,
        concat!("Size of: ", stringify!(Worker_ComponentVtable))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_ComponentVtable>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_ComponentVtable))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).component_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(component_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).user_data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).command_request_free as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(command_request_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).command_request_copy as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(command_request_copy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).command_request_deserialize
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(command_request_deserialize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).command_request_serialize as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(command_request_serialize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).command_response_free as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(command_response_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).command_response_copy as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(command_response_copy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).command_response_deserialize
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(command_response_deserialize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).command_response_serialize
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(command_response_serialize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).component_data_free as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(component_data_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).component_data_copy as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(component_data_copy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).component_data_deserialize
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(component_data_deserialize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).component_data_serialize as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(component_data_serialize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).component_update_free as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(component_update_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).component_update_copy as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(component_update_copy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).component_update_deserialize
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(component_update_deserialize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentVtable>())).component_update_serialize
                as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentVtable),
            "::",
            stringify!(component_update_serialize)
        )
    );
}
/// An object used to represent a command request by either raw schema data or some user-defined
/// handle type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandRequest {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_CommandRequest,
    pub user_handle: *mut Worker_CommandRequestHandle,
}
#[test]
fn bindgen_test_layout_Worker_CommandRequest() {
    assert_eq!(
        ::std::mem::size_of::<Worker_CommandRequest>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_CommandRequest))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_CommandRequest>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_CommandRequest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_CommandRequest>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandRequest),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandRequest>())).component_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandRequest),
            "::",
            stringify!(component_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandRequest>())).schema_type as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandRequest),
            "::",
            stringify!(schema_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandRequest>())).user_handle as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandRequest),
            "::",
            stringify!(user_handle)
        )
    );
}
/// An object used to represent a command response by either raw schema data or some user-defined
/// handle type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandResponse {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_CommandResponse,
    pub user_handle: *mut Worker_CommandResponseHandle,
}
#[test]
fn bindgen_test_layout_Worker_CommandResponse() {
    assert_eq!(
        ::std::mem::size_of::<Worker_CommandResponse>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_CommandResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_CommandResponse>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_CommandResponse))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_CommandResponse>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandResponse),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandResponse>())).component_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandResponse),
            "::",
            stringify!(component_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandResponse>())).schema_type as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandResponse),
            "::",
            stringify!(schema_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandResponse>())).user_handle as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandResponse),
            "::",
            stringify!(user_handle)
        )
    );
}
/// An object used to represent a component data snapshot by either raw schema data or some
/// user-defined handle type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentData {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_ComponentData,
    pub user_handle: *mut Worker_ComponentDataHandle,
}
#[test]
fn bindgen_test_layout_Worker_ComponentData() {
    assert_eq!(
        ::std::mem::size_of::<Worker_ComponentData>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_ComponentData))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_ComponentData>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_ComponentData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_ComponentData>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentData),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentData>())).component_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentData),
            "::",
            stringify!(component_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentData>())).schema_type as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentData),
            "::",
            stringify!(schema_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentData>())).user_handle as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentData),
            "::",
            stringify!(user_handle)
        )
    );
}
/// An object used to represent a component update by either raw schema data or some user-defined
/// handle type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentUpdate {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_ComponentUpdate,
    pub user_handle: *mut Worker_ComponentUpdateHandle,
}
#[test]
fn bindgen_test_layout_Worker_ComponentUpdate() {
    assert_eq!(
        ::std::mem::size_of::<Worker_ComponentUpdate>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_ComponentUpdate))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_ComponentUpdate>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_ComponentUpdate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_ComponentUpdate>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentUpdate),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentUpdate>())).component_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentUpdate),
            "::",
            stringify!(component_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentUpdate>())).schema_type as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentUpdate),
            "::",
            stringify!(schema_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentUpdate>())).user_handle as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentUpdate),
            "::",
            stringify!(user_handle)
        )
    );
}
extern "C" {
    /// Acquire a reference to extend the lifetime of a command request owned by the SDK.
    pub fn Worker_AcquireCommandRequest(
        request: *const Worker_CommandRequest,
    ) -> *mut Worker_CommandRequest;
}
extern "C" {
    /// Acquire a reference to extend the lifetime of a command response owned by the SDK.
    pub fn Worker_AcquireCommandResponse(
        response: *const Worker_CommandResponse,
    ) -> *mut Worker_CommandResponse;
}
extern "C" {
    /// Acquire a reference to extend the lifetime of a component data snapshot owned by the SDK.
    pub fn Worker_AcquireComponentData(
        data: *const Worker_ComponentData,
    ) -> *mut Worker_ComponentData;
}
extern "C" {
    /// Acquire a reference to extend the lifetime of a component update owned by the SDK.
    pub fn Worker_AcquireComponentUpdate(
        update: *const Worker_ComponentUpdate,
    ) -> *mut Worker_ComponentUpdate;
}
extern "C" {
    /// Release a reference obtained by Worker_AcquireCommandRequest.
    pub fn Worker_ReleaseCommandRequest(request: *mut Worker_CommandRequest);
}
extern "C" {
    /// Release a reference obtained by Worker_AcquireCommandResponse.
    pub fn Worker_ReleaseCommandResponse(response: *mut Worker_CommandResponse);
}
extern "C" {
    /// Release a reference obtained by Worker_AcquireComponentData.
    pub fn Worker_ReleaseComponentData(data: *mut Worker_ComponentData);
}
extern "C" {
    /// Release a reference obtained by Worker_AcquireComponentUpdate.
    pub fn Worker_ReleaseComponentUpdate(update: *mut Worker_ComponentUpdate);
}
/// Represents an entity with an ID and a component data snapshot.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Entity {
    /// The ID of the entity.
    pub entity_id: Worker_EntityId,
    /// Number of components for the entity.
    pub component_count: u32,
    /// Array of initial component data for the entity.
    pub components: *const Worker_ComponentData,
}
#[test]
fn bindgen_test_layout_Worker_Entity() {
    assert_eq!(
        ::std::mem::size_of::<Worker_Entity>(),
        24usize,
        concat!("Size of: ", stringify!(Worker_Entity))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_Entity>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_Entity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_Entity>())).entity_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Entity),
            "::",
            stringify!(entity_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_Entity>())).component_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Entity),
            "::",
            stringify!(component_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_Entity>())).components as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Entity),
            "::",
            stringify!(components)
        )
    );
}
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_ENTITY_ID: Worker_ConstraintType = 1;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_COMPONENT: Worker_ConstraintType = 2;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_SPHERE: Worker_ConstraintType = 3;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_AND: Worker_ConstraintType = 4;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_OR: Worker_ConstraintType = 5;
pub const Worker_ConstraintType_WORKER_CONSTRAINT_TYPE_NOT: Worker_ConstraintType = 6;
pub type Worker_ConstraintType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_EntityIdConstraint {
    pub entity_id: Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_EntityIdConstraint() {
    assert_eq!(
        ::std::mem::size_of::<Worker_EntityIdConstraint>(),
        8usize,
        concat!("Size of: ", stringify!(Worker_EntityIdConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_EntityIdConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_EntityIdConstraint))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_EntityIdConstraint>())).entity_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_EntityIdConstraint),
            "::",
            stringify!(entity_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentConstraint {
    pub component_id: Worker_ComponentId,
}
#[test]
fn bindgen_test_layout_Worker_ComponentConstraint() {
    assert_eq!(
        ::std::mem::size_of::<Worker_ComponentConstraint>(),
        4usize,
        concat!("Size of: ", stringify!(Worker_ComponentConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_ComponentConstraint>(),
        4usize,
        concat!("Alignment of ", stringify!(Worker_ComponentConstraint))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentConstraint>())).component_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentConstraint),
            "::",
            stringify!(component_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SphereConstraint {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub radius: f64,
}
#[test]
fn bindgen_test_layout_Worker_SphereConstraint() {
    assert_eq!(
        ::std::mem::size_of::<Worker_SphereConstraint>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_SphereConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_SphereConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_SphereConstraint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_SphereConstraint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_SphereConstraint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_SphereConstraint>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_SphereConstraint),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_SphereConstraint>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_SphereConstraint),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_SphereConstraint>())).radius as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_SphereConstraint),
            "::",
            stringify!(radius)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_AndConstraint {
    pub constraint_count: u32,
    pub constraints: *mut Worker_Constraint,
}
#[test]
fn bindgen_test_layout_Worker_AndConstraint() {
    assert_eq!(
        ::std::mem::size_of::<Worker_AndConstraint>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_AndConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_AndConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_AndConstraint))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_AndConstraint>())).constraint_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_AndConstraint),
            "::",
            stringify!(constraint_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_AndConstraint>())).constraints as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_AndConstraint),
            "::",
            stringify!(constraints)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_OrConstraint {
    pub constraint_count: u32,
    pub constraints: *mut Worker_Constraint,
}
#[test]
fn bindgen_test_layout_Worker_OrConstraint() {
    assert_eq!(
        ::std::mem::size_of::<Worker_OrConstraint>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_OrConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_OrConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_OrConstraint))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_OrConstraint>())).constraint_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_OrConstraint),
            "::",
            stringify!(constraint_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_OrConstraint>())).constraints as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_OrConstraint),
            "::",
            stringify!(constraints)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_NotConstraint {
    pub constraint: *mut Worker_Constraint,
}
#[test]
fn bindgen_test_layout_Worker_NotConstraint() {
    assert_eq!(
        ::std::mem::size_of::<Worker_NotConstraint>(),
        8usize,
        concat!("Size of: ", stringify!(Worker_NotConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_NotConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_NotConstraint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_NotConstraint>())).constraint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_NotConstraint),
            "::",
            stringify!(constraint)
        )
    );
}
/// A single query constraint.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Worker_Constraint {
    /// The type of constraint, defined using Worker_ConstraintType.
    pub constraint_type: u8,
    pub __bindgen_anon_1: Worker_Constraint__bindgen_ty_1,
}
/// Union with fields corresponding to each constraint type.
#[repr(C)]
#[derive(Copy, Clone)]
pub union Worker_Constraint__bindgen_ty_1 {
    pub entity_id_constraint: Worker_EntityIdConstraint,
    pub component_constraint: Worker_ComponentConstraint,
    pub sphere_constraint: Worker_SphereConstraint,
    pub and_constraint: Worker_AndConstraint,
    pub or_constraint: Worker_OrConstraint,
    pub not_constraint: Worker_NotConstraint,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_Worker_Constraint__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Worker_Constraint__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_Constraint__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_Constraint__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_Constraint__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Constraint__bindgen_ty_1>())).entity_id_constraint
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Constraint__bindgen_ty_1),
            "::",
            stringify!(entity_id_constraint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Constraint__bindgen_ty_1>())).component_constraint
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Constraint__bindgen_ty_1),
            "::",
            stringify!(component_constraint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Constraint__bindgen_ty_1>())).sphere_constraint
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Constraint__bindgen_ty_1),
            "::",
            stringify!(sphere_constraint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Constraint__bindgen_ty_1>())).and_constraint as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Constraint__bindgen_ty_1),
            "::",
            stringify!(and_constraint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Constraint__bindgen_ty_1>())).or_constraint as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Constraint__bindgen_ty_1),
            "::",
            stringify!(or_constraint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Constraint__bindgen_ty_1>())).not_constraint as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Constraint__bindgen_ty_1),
            "::",
            stringify!(not_constraint)
        )
    );
}
#[test]
fn bindgen_test_layout_Worker_Constraint() {
    assert_eq!(
        ::std::mem::size_of::<Worker_Constraint>(),
        40usize,
        concat!("Size of: ", stringify!(Worker_Constraint))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_Constraint>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_Constraint))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Constraint>())).constraint_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Constraint),
            "::",
            stringify!(constraint_type)
        )
    );
}
pub const Worker_ResultType_WORKER_RESULT_TYPE_COUNT: Worker_ResultType = 1;
pub const Worker_ResultType_WORKER_RESULT_TYPE_SNAPSHOT: Worker_ResultType = 2;
pub type Worker_ResultType = u32;
/// An entity query.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Worker_EntityQuery {
    /// The constraint for this query.
    pub constraint: Worker_Constraint,
    /// Result type for this query, using Worker_ResultType.
    pub result_type: u8,
    /// Number of component IDs in the array for a snapshot result type.
    pub snapshot_result_type_component_id_count: u32,
    /// Pointer to component ID data for a snapshot result type. NULL means all component IDs.
    pub snapshot_result_type_component_ids: *const Worker_ComponentId,
}
#[test]
fn bindgen_test_layout_Worker_EntityQuery() {
    assert_eq!(
        ::std::mem::size_of::<Worker_EntityQuery>(),
        56usize,
        concat!("Size of: ", stringify!(Worker_EntityQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_EntityQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_EntityQuery))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_EntityQuery>())).constraint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_EntityQuery),
            "::",
            stringify!(constraint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_EntityQuery>())).result_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_EntityQuery),
            "::",
            stringify!(result_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_EntityQuery>())).snapshot_result_type_component_id_count
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_EntityQuery),
            "::",
            stringify!(snapshot_result_type_component_id_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_EntityQuery>())).snapshot_result_type_component_ids
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_EntityQuery),
            "::",
            stringify!(snapshot_result_type_component_ids)
        )
    );
}
/// An interest override for a particular (entity ID, component ID) pair.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_InterestOverride {
    /// The ID of the component for which interest is being overridden.
    pub component_id: u32,
    /// Whether the worker is interested in this component.
    pub is_interested: u8,
}
#[test]
fn bindgen_test_layout_Worker_InterestOverride() {
    assert_eq!(
        ::std::mem::size_of::<Worker_InterestOverride>(),
        8usize,
        concat!("Size of: ", stringify!(Worker_InterestOverride))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_InterestOverride>(),
        4usize,
        concat!("Alignment of ", stringify!(Worker_InterestOverride))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_InterestOverride>())).component_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_InterestOverride),
            "::",
            stringify!(component_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_InterestOverride>())).is_interested as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_InterestOverride),
            "::",
            stringify!(is_interested)
        )
    );
}
/// Worker attributes that are part of a worker's runtime configuration.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_WorkerAttributes {
    /// Number of worker attributes.
    pub attribute_count: u32,
    /// Will be NULL if there are no attributes associated with the worker.
    pub attributes: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_WorkerAttributes() {
    assert_eq!(
        ::std::mem::size_of::<Worker_WorkerAttributes>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_WorkerAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_WorkerAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_WorkerAttributes))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_WorkerAttributes>())).attribute_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_WorkerAttributes),
            "::",
            stringify!(attribute_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_WorkerAttributes>())).attributes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_WorkerAttributes),
            "::",
            stringify!(attributes)
        )
    );
}
/// Data for a log message from the SDK.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DisconnectOp {
    /// The reason for the disconnect.
    pub reason: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_DisconnectOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_DisconnectOp>(),
        8usize,
        concat!("Size of: ", stringify!(Worker_DisconnectOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_DisconnectOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_DisconnectOp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_DisconnectOp>())).reason as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_DisconnectOp),
            "::",
            stringify!(reason)
        )
    );
}
/// Data for a FlagUpdate operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_FlagUpdateOp {
    /// The name of the updated worker flag.
    pub name: *const ::std::os::raw::c_char,
    /// The new value of the updated worker flag.
    /// A null value indicates that the flag has been deleted.
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_FlagUpdateOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_FlagUpdateOp>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_FlagUpdateOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_FlagUpdateOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_FlagUpdateOp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_FlagUpdateOp>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_FlagUpdateOp),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_FlagUpdateOp>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_FlagUpdateOp),
            "::",
            stringify!(value)
        )
    );
}
/// Data for a log message from the SDK.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LogMessageOp {
    /// The severity of the log message; defined in the Worker_LogLevel enumeration.
    pub level: u8,
    /// The message.
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_LogMessageOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_LogMessageOp>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_LogMessageOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_LogMessageOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_LogMessageOp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_LogMessageOp>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LogMessageOp),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_LogMessageOp>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LogMessageOp),
            "::",
            stringify!(message)
        )
    );
}
/// Data for a set of built-in metrics reported by the SDK.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_MetricsOp {
    pub metrics: Worker_Metrics,
}
#[test]
fn bindgen_test_layout_Worker_MetricsOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_MetricsOp>(),
        40usize,
        concat!("Size of: ", stringify!(Worker_MetricsOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_MetricsOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_MetricsOp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_MetricsOp>())).metrics as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_MetricsOp),
            "::",
            stringify!(metrics)
        )
    );
}
/// Data for a critical section boundary (enter or leave) operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CriticalSectionOp {
    /// Whether the protocol is entering a critical section (true) or leaving it (false).
    pub in_critical_section: u8,
}
#[test]
fn bindgen_test_layout_Worker_CriticalSectionOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_CriticalSectionOp>(),
        1usize,
        concat!("Size of: ", stringify!(Worker_CriticalSectionOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_CriticalSectionOp>(),
        1usize,
        concat!("Alignment of ", stringify!(Worker_CriticalSectionOp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CriticalSectionOp>())).in_critical_section as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CriticalSectionOp),
            "::",
            stringify!(in_critical_section)
        )
    );
}
/// Data for an AddEntity operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_AddEntityOp {
    /// The ID of the entity that was added to the worker's view of the simulation.
    pub entity_id: Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_AddEntityOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_AddEntityOp>(),
        8usize,
        concat!("Size of: ", stringify!(Worker_AddEntityOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_AddEntityOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_AddEntityOp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_AddEntityOp>())).entity_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_AddEntityOp),
            "::",
            stringify!(entity_id)
        )
    );
}
/// Data for a RemoveEntity operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_RemoveEntityOp {
    /// The ID of the entity that was removed from the worker's view of the simulation.
    pub entity_id: Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_RemoveEntityOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_RemoveEntityOp>(),
        8usize,
        concat!("Size of: ", stringify!(Worker_RemoveEntityOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_RemoveEntityOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_RemoveEntityOp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_RemoveEntityOp>())).entity_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_RemoveEntityOp),
            "::",
            stringify!(entity_id)
        )
    );
}
/// Data for a ReserveEntityIdResponse operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ReserveEntityIdResponseOp {
    /// The ID of the reserve entity ID request for which there was a response.
    pub request_id: Worker_RequestId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
    /// If successful, newly allocated entity id which is guaranteed to be unused in the current
    /// deployment.
    pub entity_id: Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_ReserveEntityIdResponseOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_ReserveEntityIdResponseOp>(),
        24usize,
        concat!("Size of: ", stringify!(Worker_ReserveEntityIdResponseOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_ReserveEntityIdResponseOp>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Worker_ReserveEntityIdResponseOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ReserveEntityIdResponseOp>())).request_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ReserveEntityIdResponseOp),
            "::",
            stringify!(request_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ReserveEntityIdResponseOp>())).status_code as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ReserveEntityIdResponseOp),
            "::",
            stringify!(status_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ReserveEntityIdResponseOp>())).message as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ReserveEntityIdResponseOp),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ReserveEntityIdResponseOp>())).entity_id as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ReserveEntityIdResponseOp),
            "::",
            stringify!(entity_id)
        )
    );
}
/// Data for a ReserveEntityIdsResponse operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ReserveEntityIdsResponseOp {
    /// The ID of the reserve entity ID request for which there was a response.
    pub request_id: Worker_RequestId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
    /// If successful, an ID which is the first in a contiguous range of newly allocated entity
    /// IDs which are guaranteed to be unused in the current deployment.
    pub first_entity_id: Worker_EntityId,
    /// If successful, the number of IDs reserved in the contiguous range, otherwise 0.
    pub number_of_entity_ids: u32,
}
#[test]
fn bindgen_test_layout_Worker_ReserveEntityIdsResponseOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_ReserveEntityIdsResponseOp>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_ReserveEntityIdsResponseOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_ReserveEntityIdsResponseOp>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Worker_ReserveEntityIdsResponseOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ReserveEntityIdsResponseOp>())).request_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ReserveEntityIdsResponseOp),
            "::",
            stringify!(request_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ReserveEntityIdsResponseOp>())).status_code as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ReserveEntityIdsResponseOp),
            "::",
            stringify!(status_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ReserveEntityIdsResponseOp>())).message as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ReserveEntityIdsResponseOp),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ReserveEntityIdsResponseOp>())).first_entity_id
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ReserveEntityIdsResponseOp),
            "::",
            stringify!(first_entity_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ReserveEntityIdsResponseOp>())).number_of_entity_ids
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ReserveEntityIdsResponseOp),
            "::",
            stringify!(number_of_entity_ids)
        )
    );
}
/// Data for a CreateEntity operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CreateEntityResponseOp {
    /// The ID of the request for which there was a response.
    pub request_id: Worker_RequestId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
    /// If successful, the entity ID of the newly created entity.
    pub entity_id: Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_CreateEntityResponseOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_CreateEntityResponseOp>(),
        24usize,
        concat!("Size of: ", stringify!(Worker_CreateEntityResponseOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_CreateEntityResponseOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_CreateEntityResponseOp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CreateEntityResponseOp>())).request_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CreateEntityResponseOp),
            "::",
            stringify!(request_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CreateEntityResponseOp>())).status_code as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CreateEntityResponseOp),
            "::",
            stringify!(status_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CreateEntityResponseOp>())).message as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CreateEntityResponseOp),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CreateEntityResponseOp>())).entity_id as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CreateEntityResponseOp),
            "::",
            stringify!(entity_id)
        )
    );
}
/// Data for a DeleteEntity operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DeleteEntityResponseOp {
    /// The ID of the delete entity request for which there was a command response.
    pub request_id: Worker_RequestId,
    /// The ID of the target entity of this request.
    pub entity_id: Worker_EntityId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_DeleteEntityResponseOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_DeleteEntityResponseOp>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_DeleteEntityResponseOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_DeleteEntityResponseOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_DeleteEntityResponseOp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_DeleteEntityResponseOp>())).request_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_DeleteEntityResponseOp),
            "::",
            stringify!(request_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_DeleteEntityResponseOp>())).entity_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_DeleteEntityResponseOp),
            "::",
            stringify!(entity_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_DeleteEntityResponseOp>())).status_code as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_DeleteEntityResponseOp),
            "::",
            stringify!(status_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_DeleteEntityResponseOp>())).message as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_DeleteEntityResponseOp),
            "::",
            stringify!(message)
        )
    );
}
/// A response indicating the result of an entity query request.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_EntityQueryResponseOp {
    /// The ID of the entity query request for which there was a response.
    pub request_id: Worker_RequestId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
    /// Number of entities in the result set. Reused to indicate the result itself for CountResultType
    /// queries.
    pub result_count: u32,
    /// Array of entities in the result set. Will be NULL if the query was a count query. Snapshot data
    /// in the result is deserialized with the corresponding vtable Deserialize function and freed with
    /// the vtable Free function when the OpList is destroyed.
    pub results: *const Worker_Entity,
}
#[test]
fn bindgen_test_layout_Worker_EntityQueryResponseOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_EntityQueryResponseOp>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_EntityQueryResponseOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_EntityQueryResponseOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_EntityQueryResponseOp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_EntityQueryResponseOp>())).request_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_EntityQueryResponseOp),
            "::",
            stringify!(request_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_EntityQueryResponseOp>())).status_code as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_EntityQueryResponseOp),
            "::",
            stringify!(status_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_EntityQueryResponseOp>())).message as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_EntityQueryResponseOp),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_EntityQueryResponseOp>())).result_count as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_EntityQueryResponseOp),
            "::",
            stringify!(result_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_EntityQueryResponseOp>())).results as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_EntityQueryResponseOp),
            "::",
            stringify!(results)
        )
    );
}
/// Data for an AddComponent operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_AddComponentOp {
    /// The ID of the entity for which a component was added.
    pub entity_id: Worker_EntityId,
    /// The initial data for the new component. Deserialized with the corresponding vtable Deserialize
    /// function and freed with the vtable Free function when the OpList is destroyed.
    pub data: Worker_ComponentData,
}
#[test]
fn bindgen_test_layout_Worker_AddComponentOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_AddComponentOp>(),
        40usize,
        concat!("Size of: ", stringify!(Worker_AddComponentOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_AddComponentOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_AddComponentOp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_AddComponentOp>())).entity_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_AddComponentOp),
            "::",
            stringify!(entity_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_AddComponentOp>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_AddComponentOp),
            "::",
            stringify!(data)
        )
    );
}
/// Data for a RemoveComponent operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_RemoveComponentOp {
    /// The ID of the entity for which a component was removed.
    pub entity_id: Worker_EntityId,
    /// The ID of the component that was removed.
    pub component_id: Worker_ComponentId,
}
#[test]
fn bindgen_test_layout_Worker_RemoveComponentOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_RemoveComponentOp>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_RemoveComponentOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_RemoveComponentOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_RemoveComponentOp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_RemoveComponentOp>())).entity_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_RemoveComponentOp),
            "::",
            stringify!(entity_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_RemoveComponentOp>())).component_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_RemoveComponentOp),
            "::",
            stringify!(component_id)
        )
    );
}
/// Data for an AuthorityChange operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_AuthorityChangeOp {
    /// The ID of the entity for which there was an authority change.
    pub entity_id: Worker_EntityId,
    /// The ID of the component over which the worker's authority has changed.
    pub component_id: Worker_ComponentId,
    /// The authority state of the component, using the Worker_Authority enumeration.
    pub authority: u8,
}
#[test]
fn bindgen_test_layout_Worker_AuthorityChangeOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_AuthorityChangeOp>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_AuthorityChangeOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_AuthorityChangeOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_AuthorityChangeOp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_AuthorityChangeOp>())).entity_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_AuthorityChangeOp),
            "::",
            stringify!(entity_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_AuthorityChangeOp>())).component_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_AuthorityChangeOp),
            "::",
            stringify!(component_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_AuthorityChangeOp>())).authority as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_AuthorityChangeOp),
            "::",
            stringify!(authority)
        )
    );
}
/// Data for a ComponentUpdate operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ComponentUpdateOp {
    /// The ID of the entity for which there was a component update.
    pub entity_id: Worker_EntityId,
    /// The new component data for the updated entity. Deserialized with the corresponding vtable
    /// Deserialize function and freed with the vtable Free function when the OpList is destroyed.
    pub update: Worker_ComponentUpdate,
}
#[test]
fn bindgen_test_layout_Worker_ComponentUpdateOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_ComponentUpdateOp>(),
        40usize,
        concat!("Size of: ", stringify!(Worker_ComponentUpdateOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_ComponentUpdateOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_ComponentUpdateOp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ComponentUpdateOp>())).entity_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentUpdateOp),
            "::",
            stringify!(entity_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_ComponentUpdateOp>())).update as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ComponentUpdateOp),
            "::",
            stringify!(update)
        )
    );
}
/// Data for a CommandRequest operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandRequestOp {
    /// The incoming command request ID.
    pub request_id: Worker_RequestId,
    /// The ID of the entity for which there was a command request.
    pub entity_id: Worker_EntityId,
    /// Upper bound on request timeout provided by the platform.
    pub timeout_millis: u32,
    /// The ID of the worker that sent the request.
    pub caller_worker_id: *const ::std::os::raw::c_char,
    /// The attributes of the worker that sent the request.
    pub caller_attribute_set: Worker_WorkerAttributes,
    /// The command request data. Deserialized with the corresponding vtable Deserialize function and
    /// freed with the vtable Free function when the OpList is destroyed.
    pub request: Worker_CommandRequest,
}
#[test]
fn bindgen_test_layout_Worker_CommandRequestOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_CommandRequestOp>(),
        80usize,
        concat!("Size of: ", stringify!(Worker_CommandRequestOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_CommandRequestOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_CommandRequestOp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandRequestOp>())).request_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandRequestOp),
            "::",
            stringify!(request_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandRequestOp>())).entity_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandRequestOp),
            "::",
            stringify!(entity_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandRequestOp>())).timeout_millis as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandRequestOp),
            "::",
            stringify!(timeout_millis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandRequestOp>())).caller_worker_id as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandRequestOp),
            "::",
            stringify!(caller_worker_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandRequestOp>())).caller_attribute_set as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandRequestOp),
            "::",
            stringify!(caller_attribute_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_CommandRequestOp>())).request as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandRequestOp),
            "::",
            stringify!(request)
        )
    );
}
/// Data for a CommandResponse operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandResponseOp {
    /// The ID of the command request for which there was a command response.
    pub request_id: Worker_RequestId,
    /// The ID of the entity originally targeted by the command request.
    pub entity_id: Worker_EntityId,
    /// Status code of the response, using Worker_StatusCode.
    pub status_code: u8,
    /// The error message.
    pub message: *const ::std::os::raw::c_char,
    /// The command response data. Deserialized with the corresponding vtable Deserialize function and
    /// freed with the vtable Free function when the OpList is destroyed.
    pub response: Worker_CommandResponse,
    /// The command ID given to Worker_Connection_SendCommandRequest.
    pub command_id: u32,
}
#[test]
fn bindgen_test_layout_Worker_CommandResponseOp() {
    assert_eq!(
        ::std::mem::size_of::<Worker_CommandResponseOp>(),
        72usize,
        concat!("Size of: ", stringify!(Worker_CommandResponseOp))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_CommandResponseOp>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_CommandResponseOp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandResponseOp>())).request_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandResponseOp),
            "::",
            stringify!(request_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandResponseOp>())).entity_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandResponseOp),
            "::",
            stringify!(entity_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandResponseOp>())).status_code as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandResponseOp),
            "::",
            stringify!(status_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandResponseOp>())).message as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandResponseOp),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandResponseOp>())).response as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandResponseOp),
            "::",
            stringify!(response)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandResponseOp>())).command_id as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandResponseOp),
            "::",
            stringify!(command_id)
        )
    );
}
pub const Worker_OpType_WORKER_OP_TYPE_DISCONNECT: Worker_OpType = 1;
pub const Worker_OpType_WORKER_OP_TYPE_FLAG_UPDATE: Worker_OpType = 2;
pub const Worker_OpType_WORKER_OP_TYPE_LOG_MESSAGE: Worker_OpType = 3;
pub const Worker_OpType_WORKER_OP_TYPE_METRICS: Worker_OpType = 4;
pub const Worker_OpType_WORKER_OP_TYPE_CRITICAL_SECTION: Worker_OpType = 5;
pub const Worker_OpType_WORKER_OP_TYPE_ADD_ENTITY: Worker_OpType = 6;
pub const Worker_OpType_WORKER_OP_TYPE_REMOVE_ENTITY: Worker_OpType = 7;
pub const Worker_OpType_WORKER_OP_TYPE_RESERVE_ENTITY_ID_RESPONSE: Worker_OpType = 8;
pub const Worker_OpType_WORKER_OP_TYPE_RESERVE_ENTITY_IDS_RESPONSE: Worker_OpType = 9;
pub const Worker_OpType_WORKER_OP_TYPE_CREATE_ENTITY_RESPONSE: Worker_OpType = 10;
pub const Worker_OpType_WORKER_OP_TYPE_DELETE_ENTITY_RESPONSE: Worker_OpType = 11;
pub const Worker_OpType_WORKER_OP_TYPE_ENTITY_QUERY_RESPONSE: Worker_OpType = 12;
pub const Worker_OpType_WORKER_OP_TYPE_ADD_COMPONENT: Worker_OpType = 13;
pub const Worker_OpType_WORKER_OP_TYPE_REMOVE_COMPONENT: Worker_OpType = 14;
pub const Worker_OpType_WORKER_OP_TYPE_AUTHORITY_CHANGE: Worker_OpType = 15;
pub const Worker_OpType_WORKER_OP_TYPE_COMPONENT_UPDATE: Worker_OpType = 16;
pub const Worker_OpType_WORKER_OP_TYPE_COMMAND_REQUEST: Worker_OpType = 17;
pub const Worker_OpType_WORKER_OP_TYPE_COMMAND_RESPONSE: Worker_OpType = 18;
/// Enum defining different possible op types.
pub type Worker_OpType = u32;
/// Data for a single op contained within an op list.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Worker_Op {
    /// The type of this op, defined in Worker_OpType.
    pub op_type: u8,
    pub __bindgen_anon_1: Worker_Op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Worker_Op__bindgen_ty_1 {
    pub disconnect: Worker_DisconnectOp,
    pub flag_update: Worker_FlagUpdateOp,
    pub log_message: Worker_LogMessageOp,
    pub metrics: Worker_MetricsOp,
    pub critical_section: Worker_CriticalSectionOp,
    pub add_entity: Worker_AddEntityOp,
    pub remove_entity: Worker_RemoveEntityOp,
    pub reserve_entity_id_response: Worker_ReserveEntityIdResponseOp,
    pub reserve_entity_ids_response: Worker_ReserveEntityIdsResponseOp,
    pub create_entity_response: Worker_CreateEntityResponseOp,
    pub delete_entity_response: Worker_DeleteEntityResponseOp,
    pub entity_query_response: Worker_EntityQueryResponseOp,
    pub add_component: Worker_AddComponentOp,
    pub remove_component: Worker_RemoveComponentOp,
    pub authority_change: Worker_AuthorityChangeOp,
    pub component_update: Worker_ComponentUpdateOp,
    pub command_request: Worker_CommandRequestOp,
    pub command_response: Worker_CommandResponseOp,
    _bindgen_union_align: [u64; 10usize],
}
#[test]
fn bindgen_test_layout_Worker_Op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Worker_Op__bindgen_ty_1>(),
        80usize,
        concat!("Size of: ", stringify!(Worker_Op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_Op__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_Op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).disconnect as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(disconnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).flag_update as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(flag_update)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).log_message as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(log_message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).metrics as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(metrics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).critical_section as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(critical_section)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).add_entity as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(add_entity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).remove_entity as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(remove_entity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).reserve_entity_id_response
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(reserve_entity_id_response)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).reserve_entity_ids_response
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(reserve_entity_ids_response)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).create_entity_response as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(create_entity_response)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).delete_entity_response as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(delete_entity_response)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).entity_query_response as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(entity_query_response)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).add_component as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(add_component)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).remove_component as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(remove_component)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).authority_change as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(authority_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).component_update as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(component_update)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).command_request as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(command_request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Op__bindgen_ty_1>())).command_response as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op__bindgen_ty_1),
            "::",
            stringify!(command_response)
        )
    );
}
#[test]
fn bindgen_test_layout_Worker_Op() {
    assert_eq!(
        ::std::mem::size_of::<Worker_Op>(),
        88usize,
        concat!("Size of: ", stringify!(Worker_Op))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_Op>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_Op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_Op>())).op_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Op),
            "::",
            stringify!(op_type)
        )
    );
}
/// An op list, usually returned by WorkerProtocol_Connection_GetOpList.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_OpList {
    pub ops: *mut Worker_Op,
    pub op_count: u32,
}
#[test]
fn bindgen_test_layout_Worker_OpList() {
    assert_eq!(
        ::std::mem::size_of::<Worker_OpList>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_OpList))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_OpList>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_OpList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_OpList>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_OpList),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_OpList>())).op_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_OpList),
            "::",
            stringify!(op_count)
        )
    );
}
/// Parameters for configuring a RakNet connection. Used by Worker_NetworkParameters.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_RakNetNetworkParameters {
    /// Time (in milliseconds) that RakNet should use for its heartbeat protocol.
    pub heartbeat_timeout_millis: u32,
}
#[test]
fn bindgen_test_layout_Worker_RakNetNetworkParameters() {
    assert_eq!(
        ::std::mem::size_of::<Worker_RakNetNetworkParameters>(),
        4usize,
        concat!("Size of: ", stringify!(Worker_RakNetNetworkParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_RakNetNetworkParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(Worker_RakNetNetworkParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_RakNetNetworkParameters>())).heartbeat_timeout_millis
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_RakNetNetworkParameters),
            "::",
            stringify!(heartbeat_timeout_millis)
        )
    );
}
/// Parameters for configuring a TCP connection. Used by Worker_NetworkParameters.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_TcpNetworkParameters {
    /// The number of multiplexed TCP connections to use.
    pub multiplex_level: u8,
    /// Size in bytes of the TCP send buffer.
    pub send_buffer_size: u32,
    /// Size in bytes of the TCP receive buffer.
    pub receive_buffer_size: u32,
    /// Whether to enable TCP_NODELAY.
    pub no_delay: u8,
}
#[test]
fn bindgen_test_layout_Worker_TcpNetworkParameters() {
    assert_eq!(
        ::std::mem::size_of::<Worker_TcpNetworkParameters>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_TcpNetworkParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_TcpNetworkParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(Worker_TcpNetworkParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_TcpNetworkParameters>())).multiplex_level as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_TcpNetworkParameters),
            "::",
            stringify!(multiplex_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_TcpNetworkParameters>())).send_buffer_size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_TcpNetworkParameters),
            "::",
            stringify!(send_buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_TcpNetworkParameters>())).receive_buffer_size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_TcpNetworkParameters),
            "::",
            stringify!(receive_buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_TcpNetworkParameters>())).no_delay as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_TcpNetworkParameters),
            "::",
            stringify!(no_delay)
        )
    );
}
/// Use this flag to connect over TCP.
pub const Worker_NetworkConnectionType_WORKER_NETWORK_CONNECTION_TYPE_TCP:
    Worker_NetworkConnectionType = 0;
/// Use this flag to connect over RakNet.
pub const Worker_NetworkConnectionType_WORKER_NETWORK_CONNECTION_TYPE_RAKNET:
    Worker_NetworkConnectionType = 1;
/// Network connection type used by the Worker_NetworkParameters struct.
pub type Worker_NetworkConnectionType = u32;
/// Parameters for configuring the network connection.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_NetworkParameters {
    /// Set this flag to non-zero to connect to SpatialOS using the externally-visible IP address. This
    /// flag must be set when connecting externally (i.e. from outside the cloud) to a cloud
    /// deployment.
    pub use_external_ip: u8,
    /// Type of network connection to use when connecting to SpatialOS, defined in
    /// Worker_NetworkConnectionType.
    pub connection_type: u8,
    /// Parameters used if the WORKER_NETWORK_RAKNET flag is set.
    pub raknet: Worker_RakNetNetworkParameters,
    /// Parameters used if the WORKER_NETWORK_TCP flag is set.
    pub tcp: Worker_TcpNetworkParameters,
    /// Timeout for the connection to SpatialOS to be established.
    pub connection_timeout_millis: u64,
    /// Default timeout for worker commands if one is not specified when command is sent.
    pub default_command_timeout_millis: u32,
}
#[test]
fn bindgen_test_layout_Worker_NetworkParameters() {
    assert_eq!(
        ::std::mem::size_of::<Worker_NetworkParameters>(),
        40usize,
        concat!("Size of: ", stringify!(Worker_NetworkParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_NetworkParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_NetworkParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_NetworkParameters>())).use_external_ip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_NetworkParameters),
            "::",
            stringify!(use_external_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_NetworkParameters>())).connection_type as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_NetworkParameters),
            "::",
            stringify!(connection_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_NetworkParameters>())).raknet as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_NetworkParameters),
            "::",
            stringify!(raknet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_NetworkParameters>())).tcp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_NetworkParameters),
            "::",
            stringify!(tcp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_NetworkParameters>())).connection_timeout_millis
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_NetworkParameters),
            "::",
            stringify!(connection_timeout_millis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_NetworkParameters>())).default_command_timeout_millis
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_NetworkParameters),
            "::",
            stringify!(default_command_timeout_millis)
        )
    );
}
/// Tuning parameters for configuring protocol logging in the SDK. Used by
/// Worker_ConnectionParameters.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ProtocolLoggingParameters {
    /// Log file names are prefixed with this prefix, are numbered, and have the extension .log.
    pub log_prefix: *const ::std::os::raw::c_char,
    /// Maximum number of log files to keep. Note that logs from any previous protocol logging
    /// sessions will be overwritten.
    pub max_log_files: u32,
    /// Once the size of a log file reaches this size, a new log file is created.
    pub max_log_file_size_bytes: u32,
}
#[test]
fn bindgen_test_layout_Worker_ProtocolLoggingParameters() {
    assert_eq!(
        ::std::mem::size_of::<Worker_ProtocolLoggingParameters>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_ProtocolLoggingParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_ProtocolLoggingParameters>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Worker_ProtocolLoggingParameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ProtocolLoggingParameters>())).log_prefix as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ProtocolLoggingParameters),
            "::",
            stringify!(log_prefix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ProtocolLoggingParameters>())).max_log_files as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ProtocolLoggingParameters),
            "::",
            stringify!(max_log_files)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ProtocolLoggingParameters>())).max_log_file_size_bytes
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ProtocolLoggingParameters),
            "::",
            stringify!(max_log_file_size_bytes)
        )
    );
}
/// Parameters for configuring thread affinity. Affinity masks are bit masks where
/// having 1 in the nth least significant position means the thread will be permitted to run
/// on the nth core. If an affinity mask is set to zero, the group of threads using that mask
/// will have no thread affinity. Used by Worker_ConnectionParameters.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ThreadAffinityParameters {
    /// Affinity mask for threads related to receiving network ops.
    pub receive_threads_affinity_mask: u64,
    /// Affinity mask for threads related to sending network ops.
    pub send_threads_affinity_mask: u64,
    /// Affinity mask for short-lived threads.
    pub temporary_threads_affinity_mask: u64,
}
#[test]
fn bindgen_test_layout_Worker_ThreadAffinityParameters() {
    assert_eq!(
        ::std::mem::size_of::<Worker_ThreadAffinityParameters>(),
        24usize,
        concat!("Size of: ", stringify!(Worker_ThreadAffinityParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_ThreadAffinityParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_ThreadAffinityParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ThreadAffinityParameters>()))
                .receive_threads_affinity_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ThreadAffinityParameters),
            "::",
            stringify!(receive_threads_affinity_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ThreadAffinityParameters>())).send_threads_affinity_mask
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ThreadAffinityParameters),
            "::",
            stringify!(send_threads_affinity_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ThreadAffinityParameters>()))
                .temporary_threads_affinity_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ThreadAffinityParameters),
            "::",
            stringify!(temporary_threads_affinity_mask)
        )
    );
}
/// Parameters for creating a Worker_Connection and connecting to SpatialOS.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ConnectionParameters {
    /// Worker type (platform).
    pub worker_type: *const ::std::os::raw::c_char,
    /// Network parameters.
    pub network: Worker_NetworkParameters,
    /// Number of messages that can be stored on the send queue. When the send queue is full, calls to
    /// Worker_Connection_Send functions can block.
    pub send_queue_capacity: u32,
    /// Number of messages that can be stored on the receive queue. When the receive queue is full,
    /// SpatialOS can apply QoS and drop messages to the worker.
    pub receive_queue_capacity: u32,
    /// Number of messages logged by the SDK that can be stored in the log message queue. When the log
    /// message queue is full, messages logged by the SDK can be dropped.
    pub log_message_queue_capacity: u32,
    /// The Connection tracks several internal metrics, such as send and receive queue statistics. This
    /// parameter controls how frequently the Connection will return a MetricsOp reporting its built-in
    /// metrics. If set to zero, this functionality is disabled.
    pub built_in_metrics_report_period_millis: u32,
    /// Parameters for configuring protocol parameters.
    pub protocol_logging: Worker_ProtocolLoggingParameters,
    /// Whether to enable protocol logging at startup.
    pub enable_protocol_logging_at_startup: u8,
    /// Parameters for configuring thread affinity.
    pub thread_affinity: Worker_ThreadAffinityParameters,
    /// Number of component vtables.
    pub component_vtable_count: u32,
    /// Component vtable for each component that the connection will deal with.
    pub component_vtables: *const Worker_ComponentVtable,
    /// Default vtable used when a component is not registered. Only used if not NULL.
    pub default_component_vtable: *const Worker_ComponentVtable,
}
#[test]
fn bindgen_test_layout_Worker_ConnectionParameters() {
    assert_eq!(
        ::std::mem::size_of::<Worker_ConnectionParameters>(),
        136usize,
        concat!("Size of: ", stringify!(Worker_ConnectionParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_ConnectionParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_ConnectionParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>())).worker_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(worker_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>())).network as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(network)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>())).send_queue_capacity as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(send_queue_capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>())).receive_queue_capacity
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(receive_queue_capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>())).log_message_queue_capacity
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(log_message_queue_capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>()))
                .built_in_metrics_report_period_millis as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(built_in_metrics_report_period_millis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>())).protocol_logging as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(protocol_logging)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>()))
                .enable_protocol_logging_at_startup as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(enable_protocol_logging_at_startup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>())).thread_affinity as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(thread_affinity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>())).component_vtable_count
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(component_vtable_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>())).component_vtables as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(component_vtables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_ConnectionParameters>())).default_component_vtable
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_ConnectionParameters),
            "::",
            stringify!(default_component_vtable)
        )
    );
}
/// Parameters for authenticating using a SpatialOS login token.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LoginTokenCredentials {
    /// The token would typically be provided on the command-line by the SpatialOS launcher.
    pub token: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_LoginTokenCredentials() {
    assert_eq!(
        ::std::mem::size_of::<Worker_LoginTokenCredentials>(),
        8usize,
        concat!("Size of: ", stringify!(Worker_LoginTokenCredentials))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_LoginTokenCredentials>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_LoginTokenCredentials))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_LoginTokenCredentials>())).token as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LoginTokenCredentials),
            "::",
            stringify!(token)
        )
    );
}
/// Parameters for authenticating using Steam credentials.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SteamCredentials {
    /// Steam ticket for the steam app ID and publisher key corresponding to the project name specified
    /// in the Worker_LocatorParameters. Typically obtained from the steam APIs.
    pub ticket: *const ::std::os::raw::c_char,
    /// Deployment tag to request access for. If non-empty, must match the following regex:
    /// [A-Za-z0-9][A-Za-z0-9_]*
    pub deployment_tag: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_SteamCredentials() {
    assert_eq!(
        ::std::mem::size_of::<Worker_SteamCredentials>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_SteamCredentials))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_SteamCredentials>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_SteamCredentials))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_SteamCredentials>())).ticket as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_SteamCredentials),
            "::",
            stringify!(ticket)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_SteamCredentials>())).deployment_tag as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_SteamCredentials),
            "::",
            stringify!(deployment_tag)
        )
    );
}
/// Parameters for authenticating using a Player Identity Token and Login Token.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_PlayerIdentityCredentials {
    /// Authenticates a user to a single deployment. Obtained from a game authentication server using
    /// a PIT.
    pub player_identity_token: *const ::std::os::raw::c_char,
    /// Uniquely identifies a user across deployments, and is provided by a game authentication
    /// server.
    pub login_token: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_Alpha_PlayerIdentityCredentials() {
    assert_eq!(
        ::std::mem::size_of::<Worker_Alpha_PlayerIdentityCredentials>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(Worker_Alpha_PlayerIdentityCredentials)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_Alpha_PlayerIdentityCredentials>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Worker_Alpha_PlayerIdentityCredentials)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Alpha_PlayerIdentityCredentials>())).player_identity_token
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Alpha_PlayerIdentityCredentials),
            "::",
            stringify!(player_identity_token)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Alpha_PlayerIdentityCredentials>())).login_token
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Alpha_PlayerIdentityCredentials),
            "::",
            stringify!(login_token)
        )
    );
}
pub const Worker_LocatorCredentialsTypes_WORKER_LOCATOR_LOGIN_TOKEN_CREDENTIALS:
    Worker_LocatorCredentialsTypes = 1;
pub const Worker_LocatorCredentialsTypes_WORKER_LOCATOR_STEAM_CREDENTIALS:
    Worker_LocatorCredentialsTypes = 2;
/// Locator credentials type used by the Worker_LocatorParameters struct.
pub type Worker_LocatorCredentialsTypes = u32;
/// Parameters for authenticating and logging in to a SpatialOS deployment.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_LocatorParameters {
    /// The name of the SpatialOS project.
    pub project_name: *const ::std::os::raw::c_char,
    /// Type of credentials to use when authenticating via the Locator, defined in
    /// Worker_LocatorCredentialsTypes
    pub credentials_type: u8,
    /// Parameters used if the WORKER_LOGIN_TOKEN_CREDENTIALS flag is set.
    pub login_token: Worker_LoginTokenCredentials,
    /// Parameters used if the WORKER_STEAM_CREDENTIALS flag is set.
    pub steam: Worker_SteamCredentials,
    /// Parameters for configuring logging.
    pub logging: Worker_ProtocolLoggingParameters,
    /// Whether to enable logging for the Locator flow.
    pub enable_logging: u8,
}
#[test]
fn bindgen_test_layout_Worker_LocatorParameters() {
    assert_eq!(
        ::std::mem::size_of::<Worker_LocatorParameters>(),
        64usize,
        concat!("Size of: ", stringify!(Worker_LocatorParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_LocatorParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_LocatorParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_LocatorParameters>())).project_name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LocatorParameters),
            "::",
            stringify!(project_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_LocatorParameters>())).credentials_type as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LocatorParameters),
            "::",
            stringify!(credentials_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_LocatorParameters>())).login_token as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LocatorParameters),
            "::",
            stringify!(login_token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_LocatorParameters>())).steam as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LocatorParameters),
            "::",
            stringify!(steam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_LocatorParameters>())).logging as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LocatorParameters),
            "::",
            stringify!(logging)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_LocatorParameters>())).enable_logging as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_LocatorParameters),
            "::",
            stringify!(enable_logging)
        )
    );
}
/// Parameters for authenticating and logging in to a SpatialOS deployment using player identity
/// credentials.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Alpha_LocatorParameters {
    /// The player identity token/login token pair used for authentication.
    pub player_identity: Worker_Alpha_PlayerIdentityCredentials,
    /// Whether to use an insecure (non-TLS) connection for local development.
    pub use_insecure_connection: u8,
    /// Parameters for configuring logging.
    pub logging: Worker_ProtocolLoggingParameters,
    /// Whether to enable logging for the Locator flow.
    pub enable_logging: u8,
}
#[test]
fn bindgen_test_layout_Worker_Alpha_LocatorParameters() {
    assert_eq!(
        ::std::mem::size_of::<Worker_Alpha_LocatorParameters>(),
        48usize,
        concat!("Size of: ", stringify!(Worker_Alpha_LocatorParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_Alpha_LocatorParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_Alpha_LocatorParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Alpha_LocatorParameters>())).player_identity as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Alpha_LocatorParameters),
            "::",
            stringify!(player_identity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Alpha_LocatorParameters>())).use_insecure_connection
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Alpha_LocatorParameters),
            "::",
            stringify!(use_insecure_connection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Alpha_LocatorParameters>())).logging as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Alpha_LocatorParameters),
            "::",
            stringify!(logging)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Alpha_LocatorParameters>())).enable_logging as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Alpha_LocatorParameters),
            "::",
            stringify!(enable_logging)
        )
    );
}
/// Details of a specific deployment obtained via Worker_Locator_GetDeploymentListAsync.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Deployment {
    /// Name of the deployment.
    pub deployment_name: *const ::std::os::raw::c_char,
    /// The name of the assembly used by this deployment.
    pub assembly_name: *const ::std::os::raw::c_char,
    /// Description of the deployment.
    pub description: *const ::std::os::raw::c_char,
    /// Number of users currently connected to the deployment.
    pub users_connected: u32,
    /// Total user capacity of the deployment.
    pub users_capacity: u32,
}
#[test]
fn bindgen_test_layout_Worker_Deployment() {
    assert_eq!(
        ::std::mem::size_of::<Worker_Deployment>(),
        32usize,
        concat!("Size of: ", stringify!(Worker_Deployment))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_Deployment>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_Deployment))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Deployment>())).deployment_name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Deployment),
            "::",
            stringify!(deployment_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_Deployment>())).assembly_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Deployment),
            "::",
            stringify!(assembly_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_Deployment>())).description as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Deployment),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Deployment>())).users_connected as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Deployment),
            "::",
            stringify!(users_connected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_Deployment>())).users_capacity as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_Deployment),
            "::",
            stringify!(users_capacity)
        )
    );
}
/// A deployment list obtained via Worker_Locator_GetDeploymentListAsync.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DeploymentList {
    /// Number of deployments.
    pub deployment_count: u32,
    /// Array of deployments.
    pub deployments: *mut Worker_Deployment,
    /// Will be non-NULL if an error occurred.
    pub error: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_DeploymentList() {
    assert_eq!(
        ::std::mem::size_of::<Worker_DeploymentList>(),
        24usize,
        concat!("Size of: ", stringify!(Worker_DeploymentList))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_DeploymentList>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_DeploymentList))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_DeploymentList>())).deployment_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_DeploymentList),
            "::",
            stringify!(deployment_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_DeploymentList>())).deployments as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_DeploymentList),
            "::",
            stringify!(deployments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_DeploymentList>())).error as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_DeploymentList),
            "::",
            stringify!(error)
        )
    );
}
/// A queue status update when connecting to a deployment via Worker_Locator_ConnectAsync.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_QueueStatus {
    /// Position in the queue. Decreases as we advance to the front of the queue.
    pub position_in_queue: u32,
    /// Will be non-NULL if an error occurred.
    pub error: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_QueueStatus() {
    assert_eq!(
        ::std::mem::size_of::<Worker_QueueStatus>(),
        16usize,
        concat!("Size of: ", stringify!(Worker_QueueStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_QueueStatus>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_QueueStatus))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_QueueStatus>())).position_in_queue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_QueueStatus),
            "::",
            stringify!(position_in_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Worker_QueueStatus>())).error as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_QueueStatus),
            "::",
            stringify!(error)
        )
    );
}
/// Command parameters. Used to modify the behaviour of a command request.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_CommandParameters {
    /// Allow command requests to bypass the bridge when this worker is authoritative over the target
    /// entity-component.
    pub allow_short_circuit: u8,
}
#[test]
fn bindgen_test_layout_Worker_CommandParameters() {
    assert_eq!(
        ::std::mem::size_of::<Worker_CommandParameters>(),
        1usize,
        concat!("Size of: ", stringify!(Worker_CommandParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_CommandParameters>(),
        1usize,
        concat!("Alignment of ", stringify!(Worker_CommandParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_CommandParameters>())).allow_short_circuit as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_CommandParameters),
            "::",
            stringify!(allow_short_circuit)
        )
    );
}
/// Locator callback typedef.
pub type Worker_DeploymentListCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        deployment_list: *const Worker_DeploymentList,
    ),
>;
/// Locator callback typedef.
pub type Worker_QueueStatusCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        queue_status: *const Worker_QueueStatus,
    ) -> u8,
>;
/// Worker flags callback typedef.
pub type Worker_GetFlagCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    /// Returns a new Worker_ConnectionParameters with default values set.
    pub fn Worker_DefaultConnectionParameters() -> Worker_ConnectionParameters;
}
extern "C" {
    /// Creates a client which can be used to connect to a SpatialOS deployment via a locator service.
    /// This is the standard flow used to connect a local worker to a cloud deployment.
    ///
    /// The hostname would typically be either "locator.improbable.io" (for production) or
    /// "locator-staging.improbable.io" (for staging).
    pub fn Worker_Locator_Create(
        hostname: *const ::std::os::raw::c_char,
        params: *const Worker_LocatorParameters,
    ) -> *mut Worker_Locator;
}
extern "C" {
    /// Frees resources for a Worker_Locator created with Worker_Locator_Create.
    pub fn Worker_Locator_Destroy(locator: *mut Worker_Locator);
}
extern "C" {
    /// Creates a client which can be used to connect to a SpatialOS deployment via the locator service.
    /// This is the new flow used to connect a local worker to a cloud deployment with a player identity
    /// token and login token.
    /// This object should not be used concurrently by multiple threads.
    pub fn Worker_Alpha_Locator_Create(
        hostname: *const ::std::os::raw::c_char,
        params: *const Worker_Alpha_LocatorParameters,
    ) -> *mut Worker_Alpha_Locator;
}
extern "C" {
    /// Frees resources for a Worker_Alpha_Locator created with Worker_Alpha_Locator_Create.
    pub fn Worker_Alpha_Locator_Destroy(locator: *mut Worker_Alpha_Locator);
}
extern "C" {
    /// Queries the current list of deployments for the project given in the
    /// Worker_LocatorParameters.
    pub fn Worker_Locator_GetDeploymentListAsync(
        locator: *const Worker_Locator,
    ) -> *mut Worker_DeploymentListFuture;
}
extern "C" {
    /// Connects to a specific deployment. The deployment name should be obtained by calling
    /// Worker_Locator_GetDeploymentListAsync. The callback should return zero to cancel queuing,
    /// or non-zero to continue queueing.
    ///
    /// Returns a Worker_ConnectionFuture that can be used to obtain a Worker_Connection
    /// by using Worker_ConnectionFuture_Get. Caller is responsible for destroying it when no
    /// longer needed by using Worker_ConnectionFuture_Destroy.
    pub fn Worker_Locator_ConnectAsync(
        locator: *const Worker_Locator,
        deployment_name: *const ::std::os::raw::c_char,
        params: *const Worker_ConnectionParameters,
        data: *mut ::std::os::raw::c_void,
        callback: Worker_QueueStatusCallback,
    ) -> *mut Worker_ConnectionFuture;
}
extern "C" {
    /// Connects to a deployment. The deployment is specified in the login token, which is
    /// provided at creation of the Worker_Alpha_Locator in Worker_Alpha_LocatorParameters, along with a
    /// player identity token.
    /// These tokens can be obtained from a game authentication server.
    pub fn Worker_Alpha_Locator_ConnectAsync(
        locator: *const Worker_Alpha_Locator,
        params: *const Worker_ConnectionParameters,
    ) -> *mut Worker_ConnectionFuture;
}
extern "C" {
    /// Connect to a SpatialOS deployment via a receptionist. This is the flow used to connect a managed
    /// worker running in the cloud alongside the deployment, and also to connect any local worker to a
    /// (local or remote) deployment via a locally-running receptionist.
    ///
    /// The hostname and port would typically be provided by SpatialOS on the command-line, if this is a
    /// managed worker on the cloud, or otherwise be predetermined (e.g. localhost:7777 for the default
    /// receptionist of a locally-running deployment).
    ///
    /// Returns a Worker_ConnectionFuture that can be used to obtain a Worker_Connection
    /// by using Worker_ConnectionFuture_Get. Caller is responsible for destroying it when no
    /// longer needed by using Worker_ConnectionFuture_Destroy.
    pub fn Worker_ConnectAsync(
        hostname: *const ::std::os::raw::c_char,
        port: u16,
        worker_id: *const ::std::os::raw::c_char,
        params: *const Worker_ConnectionParameters,
    ) -> *mut Worker_ConnectionFuture;
}
extern "C" {
    /// Destroys a Worker_DeploymentListFuture. Blocks until the future has completed.
    pub fn Worker_DeploymentListFuture_Destroy(future: *mut Worker_DeploymentListFuture);
}
extern "C" {
    /// Gets the result of a Worker_DeploymentListFuture, waiting for up to *timeout_millis to
    /// become available (or forever if timeout_millis is NULL).
    ///
    /// It is an error to call this method again once it has succeeded (e.g. not timed out) once.
    pub fn Worker_DeploymentListFuture_Get(
        future: *mut Worker_DeploymentListFuture,
        timeout_millis: *const u32,
        data: *mut ::std::os::raw::c_void,
        callback: Worker_DeploymentListCallback,
    );
}
extern "C" {
    /// Destroys a Worker_ConnectionFuture. Blocks until the future has completed.
    pub fn Worker_ConnectionFuture_Destroy(future: *mut Worker_ConnectionFuture);
}
extern "C" {
    /// Gets the result of a Worker_ConnectionFuture, waiting for up to *timeout_millis to
    /// become available (or forever if timeout_millis is NULL). It returns NULL in case of a timeout.
    ///
    /// It is an error to call this method again once it has succeeded (e.g. not timed out) once.
    pub fn Worker_ConnectionFuture_Get(
        future: *mut Worker_ConnectionFuture,
        timeout_millis: *const u32,
    ) -> *mut Worker_Connection;
}
extern "C" {
    /// Frees resources for a Worker_Connection created with Worker_ConnectAsync or
    /// Worker_Locator_ConnectAsync.
    pub fn Worker_Connection_Destroy(connection: *mut Worker_Connection);
}
extern "C" {
    /// Sends a log message from the worker to SpatialOS.
    pub fn Worker_Connection_SendLogMessage(
        connection: *mut Worker_Connection,
        log_message: *const Worker_LogMessage,
    );
}
extern "C" {
    /// Sends metrics data for the worker to SpatialOS.
    pub fn Worker_Connection_SendMetrics(
        connection: *mut Worker_Connection,
        metrics: *const Worker_Metrics,
    );
}
extern "C" {
    /// Requests SpatialOS to reserve an entity ID.
    pub fn Worker_Connection_SendReserveEntityIdRequest(
        connection: *mut Worker_Connection,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Requests SpatialOS to reserve multiple entity IDs.
    pub fn Worker_Connection_SendReserveEntityIdsRequest(
        connection: *mut Worker_Connection,
        number_of_entity_ids: u32,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Requests SpatialOS to create an entity. The entity data is serialized immediately using the
    /// corresponding vtable Serialize function; no copy is made or ownership transferred.
    pub fn Worker_Connection_SendCreateEntityRequest(
        connection: *mut Worker_Connection,
        component_count: u32,
        components: *const Worker_ComponentData,
        entity_id: *const Worker_EntityId,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Requests SpatialOS to delete an entity.
    pub fn Worker_Connection_SendDeleteEntityRequest(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Queries SpatialOS for entity data.
    pub fn Worker_Connection_SendEntityQueryRequest(
        connection: *mut Worker_Connection,
        entity_query: *const Worker_EntityQuery,
        timeout_millis: *const u32,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Sends a component update for the given entity to SpatialOS. Note that the sent component update
    /// is added as an operation to the operation list and will be returned by a subsequent call to
    /// Worker_connection_GetOpList. The update data is copied with the corresponding vtable Copy
    /// function and the copy is later freed with the vtable Free function.
    pub fn Worker_Connection_SendComponentUpdate(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        component_update: *const Worker_ComponentUpdate,
    );
}
extern "C" {
    /// Sends a command request targeting the given entity and component to SpatialOS. If timeout_millis
    /// is null, the default will be used. The request data is copied with the corresponding vtable Copy
    /// function and the copy is later freed with the vtable Free function.
    ///
    /// The command_id parameter has no effect other than being exposed in the
    /// Worker_CommandResponseOp so that callers can correctly handle command failures.
    ///
    /// The command parameters argument must not be NULL.
    pub fn Worker_Connection_SendCommandRequest(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        request: *const Worker_CommandRequest,
        command_id: u32,
        timeout_millis: *const u32,
        command_parameters: *const Worker_CommandParameters,
    ) -> Worker_RequestId;
}
extern "C" {
    /// Sends a command response for the given request ID to SpatialOS. The response data is copied with
    /// the corresponding vtable Copy function and the copy is later freed with the vtable Free function.
    pub fn Worker_Connection_SendCommandResponse(
        connection: *mut Worker_Connection,
        request_id: Worker_RequestId,
        response: *const Worker_CommandResponse,
    );
}
extern "C" {
    /// Sends an explicit failure for the given command request ID to SpatialOS.
    pub fn Worker_Connection_SendCommandFailure(
        connection: *mut Worker_Connection,
        request_id: Worker_RequestId,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// Sends a diff-based component interest update for the given entity to SpatialOS. By default, the
    /// worker receives data for all entities according to the default component interest specified in
    /// its bridge settings. This function allows interest override by (entity ID, component ID) pair to
    /// force the data to either always be sent or never be sent. Note that this does not apply if the
    /// worker is _authoritative_ over a particular (entity ID, component ID) pair, in which case the
    /// data is always sent.
    pub fn Worker_Connection_SendComponentInterest(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        interest_override: *const Worker_InterestOverride,
        interest_override_count: u32,
    );
}
extern "C" {
    /// Sends an acknowledgement of the receipt of an AuthorityLossImminent authority change for a
    /// component. Sending the acknowledgement signifies that this worker is ready to lose authority
    /// over the component.
    pub fn Worker_Connection_SendAuthorityLossImminentAcknowledgement(
        connection: *mut Worker_Connection,
        entity_id: Worker_EntityId,
        component_id: Worker_ComponentId,
    );
}
extern "C" {
    /// Enables or disables protocol logging. Logging uses the parameters specified when the connection
    /// was created. Enabling it when already enabled, or disabling it when already disabled, do nothing.
    ///
    /// Note that logs from any previous protocol logging sessions will be overwritten.
    pub fn Worker_Connection_SetProtocolLoggingEnabled(
        connection: *mut Worker_Connection,
        enabled: u8,
    );
}
extern "C" {
    /// Returns true if the connection has been successfully created and communication is ongoing.
    pub fn Worker_Connection_IsConnected(connection: *const Worker_Connection) -> u8;
}
extern "C" {
    /// Retrieves the ID of the worker as assigned by the runtime. The returned pointer points to data
    /// that is owned by the SDK and will remain valid for the lifetime of the connection.
    pub fn Worker_Connection_GetWorkerId(
        connection: *const Worker_Connection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Retrieves the attributes associated with the worker at runtime. The result to data that is owned
    /// by the SDK and will remain valid for the lifetime of the connection.
    pub fn Worker_Connection_GetWorkerAttributes(
        connection: *const Worker_Connection,
    ) -> *const Worker_WorkerAttributes;
}
extern "C" {
    /// Queries the worker flag with the given name. If the worker flag does not exist, the value will
    /// be NULL.
    ///
    /// Worker flags are remotely configurable and may change during the runtime of the worker,
    /// including addition and deletion.
    pub fn Worker_Connection_GetFlag(
        connection: *const Worker_Connection,
        name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
        callback: Worker_GetFlagCallback,
    );
}
extern "C" {
    /// Retrieves the list of operations that have occurred since the last call to this function.
    ///
    /// If timeout_millis is non-zero, the function will block until there is at least one operation to
    /// return, or the timeout has been exceeded. If the timeout is exceeded, an empty list will be
    /// returned.
    ///
    /// If timeout_millis is zero the function is non-blocking.
    ///
    /// It is the caller's responsibility to destroy the returned Worker_OpList with the
    /// Worker_OpList_Destroy function.
    pub fn Worker_Connection_GetOpList(
        connection: *mut Worker_Connection,
        timeout_millis: u32,
    ) -> *mut Worker_OpList;
}
extern "C" {
    /// Frees resources for Worker_OpList returned by Worker_Connection_GetOpList.
    pub fn Worker_OpList_Destroy(op_list: *mut Worker_OpList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotParameters {
    /// Number of component vtables.
    pub component_vtable_count: u32,
    /// Component vtable for each component that the connection will deal with.
    pub component_vtables: *const Worker_ComponentVtable,
    /// Default vtable used when a component is not registered. Only used if not NULL.
    pub default_component_vtable: *const Worker_ComponentVtable,
}
#[test]
fn bindgen_test_layout_Worker_SnapshotParameters() {
    assert_eq!(
        ::std::mem::size_of::<Worker_SnapshotParameters>(),
        24usize,
        concat!("Size of: ", stringify!(Worker_SnapshotParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Worker_SnapshotParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(Worker_SnapshotParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_SnapshotParameters>())).component_vtable_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_SnapshotParameters),
            "::",
            stringify!(component_vtable_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_SnapshotParameters>())).component_vtables as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_SnapshotParameters),
            "::",
            stringify!(component_vtables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Worker_SnapshotParameters>())).default_component_vtable
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Worker_SnapshotParameters),
            "::",
            stringify!(default_component_vtable)
        )
    );
}
extern "C" {
    /// Opens a Worker_SnapshotInputStream. The caller must manage the memory of the
    /// returned Worker_SnapshotInputStream* by calling Worker_SnapshotInputStream to
    /// write the EOF and release resources.
    ///
    /// If an error occurs, a pointer to a Worker_SnapshotInputStream is still returned.
    /// Calling Worker_SnapshotInputStream_GetError with this pointer will return
    /// an error message describing any error that occured. In the event of an error, the caller still
    /// must release the memory of the Worker_SnapshotInputStream by calling
    /// Worker_SnapshotInputStream.
    pub fn Worker_SnapshotInputStream_Create(
        filename: *const ::std::os::raw::c_char,
        params: *const Worker_SnapshotParameters,
    ) -> *mut Worker_SnapshotInputStream;
}
extern "C" {
    /// Closes the SnapshotInputStream and releases its resources.
    pub fn Worker_SnapshotInputStream_Destroy(input_stream: *mut Worker_SnapshotInputStream);
}
extern "C" {
    /// Returns zero (false) if the Worker_SnapshotInputStream has reached the EOF
    /// of the Snapshot.
    pub fn Worker_SnapshotInputStream_HasNext(input_stream: *mut Worker_SnapshotInputStream) -> u8;
}
extern "C" {
    /// Reads next Worker_Entity* entity from input_stream.
    ///
    /// Worker_SnapshotInputStream_ReadEntity manages the memory for the returned entity internally. The
    /// next call to Worker_SnapshotInputStream_ReadEntity or Worker_SnapshotInputStream_Destroy
    /// invalidates this value; use Worker_AcquireComponentData as usual to preserve component data.
    pub fn Worker_SnapshotInputStream_ReadEntity(
        input_stream: *mut Worker_SnapshotInputStream,
    ) -> *const Worker_Entity;
}
extern "C" {
    /// Must be called after any operation on Worker_SnapshotInputStream to get the error
    /// message associated with previous operation. If error is null, no error occured.
    ///
    /// Returns a read only const char* representation of the error message.
    pub fn Worker_SnapshotInputStream_GetError(
        input_stream: *mut Worker_SnapshotInputStream,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Opens Worker_SnapshotOutputStream stream. The caller must manage the memory of the
    /// returned Worker_SnapshotOutputStream* by calling
    /// Worker_SnapshotOutputStream_Destroy to write the EOF and release resources.
    ///
    /// If an error occurs, a pointer to a Worker_SnapshotOutputStream is still returned.
    /// Calling Worker_SnapshotOutputStream_GetError with this pointer will return
    /// an error message describing any error that occured. In the event of an error, the caller still
    /// must release the memory of the Worker_SnapshotOutputStream by calling
    /// Worker_SnapshotOutputStream_Destroy.
    pub fn Worker_SnapshotOutputStream_Create(
        filename: *const ::std::os::raw::c_char,
        params: *const Worker_SnapshotParameters,
    ) -> *mut Worker_SnapshotOutputStream;
}
extern "C" {
    /// Closes the snapshot output stream and releases its resources.
    pub fn Worker_SnapshotOutputStream_Destroy(output_stream: *mut Worker_SnapshotOutputStream);
}
extern "C" {
    /// Writes next entity_id, entity pair from input. Must call
    /// Worker_SnapshotOutputStream_GetError
    /// to get any error that occured during operation.
    /// Returns non-zero (true) if the write was successful.
    pub fn Worker_SnapshotOutputStream_WriteEntity(
        output_stream: *mut Worker_SnapshotOutputStream,
        entity: *const Worker_Entity,
    ) -> u8;
}
extern "C" {
    /// Must be called after any operation on Worker_SnapshotOutputStream to get the error
    /// message associated with previous operation. If error is null, no error occured.
    ///
    /// Returns a read only const char* representation of the error message.
    pub fn Worker_SnapshotOutputStream_GetError(
        output_stream: *mut Worker_SnapshotOutputStream,
    ) -> *const ::std::os::raw::c_char;
}
